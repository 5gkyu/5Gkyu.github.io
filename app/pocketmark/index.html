<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ãƒªãƒ³ã‚¯é›† â€” åˆéŸ³ãƒŸã‚¯é¢¨ã‚«ãƒ©ãƒ¼ï¼ˆè¿½åŠ UIä»˜ãï¼‰</title>
   <style>
    /* X.htmlã®é…è‰²ã«åˆã‚ã›ãŸã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ */
    :root{
      --bg: #f6fbfb;
      --card: #ffffff;
      --accent-1: #0fb8bf;
      --accent-2: #8fe3dd;
      --text: #073a46;
      --muted: #57727a;
      --radius:12px;
      --gap:12px;
      --row-h:72px;
    }

    html,body{height:100%;width:100%;margin:0;font-family:Inter, "Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;background:var(--bg);color:var(--text);overflow-x:hidden}
    /* Background image located in same folder as this HTML file */
    body{background-image: url('backimage.png');background-attachment:fixed;background-size:cover;background-position:center;min-height:100vh}
    .wrap{max-width:980px;margin:0 auto;padding:8px}
    /* Desktop layout: content row with optional left sidebar for folders */
    .content-row{display:flex;gap:12px;align-items:flex-start}
    .sidebar{display:block;width:260px;flex:0 0 260px;position:sticky;top:var(--hdr-h,0px);align-self:flex-start;max-height:calc(100vh - var(--hdr-h,0px));overflow:auto;padding:8px}
    @media(max-width:880px){.sidebar{display:none}.content-row{display:block}}
    /* Desktop: pin sidebar to viewport left edge and push main content to the right so
       there's no left gap and the right side doesn't get clipped. This only applies
       on sufficiently wide screens. */
    @media(min-width:881px){
      .sidebar{position:fixed;left:0;top:var(--hdr-h,0px);height:calc(100vh - var(--hdr-h,0px));overflow:auto;z-index:994}
      /* make the outer wrap reserve space for the fixed sidebar */
      .wrap{box-sizing:border-box;padding-left:280px;max-width:none}
      /* ensure content row takes remaining width and doesn't overflow */
      .content-row{margin:0;max-width:100%;}
      main{max-width:calc(100% - 280px);}
    }
      /* Footer styling removed - footer will not be rendered in this build */

    /* Sticky header so search is always visible */
    header.card{position:fixed;left:0;right:0;top:0;z-index:1000;background:linear-gradient(180deg, var(--card), #fbffff);backdrop-filter: blur(6px);padding:12px;border-radius:0;box-shadow:0 10px 30px rgba(2,18,22,0.06);border:1px solid rgba(6,50,58,0.04);display:flex;flex-direction:column;align-items:stretch;gap:8px}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .search{flex:1;min-width:200px;position:relative}
    .search input{width:100%;padding:12px 44px 12px 12px;border-radius:10px;border:1px solid rgba(6,50,58,0.08);background:var(--card);color:var(--text);font-size:16px;box-shadow: inset 0 1px 0 rgba(2,12,14,0.02)}
  .search{flex:1 1 auto;min-width:0}
  .search input{box-sizing:border-box}
    .search input::placeholder{color:#9fb5b7}
    .search .icon{position:absolute;right:10px;top:50%;transform:translateY(-50%);opacity:0.9}
    .selector{display:flex;gap:8px;align-items:center}
  .selector{flex:0 0 auto}
    select, button, input[type="url"]{padding:10px 12px;border-radius:10px;border:1px solid rgba(6,50,58,0.08);background:var(--card);color:var(--text)}

    /* Header controls: ensure selector and top-buttons are visible in header */
  header.card .selector{display:flex;align-items:center}
    
    .list{display:flex;flex-direction:column;gap:8px}

    .row{display:flex;align-items:center;height:var(--row-h);gap:12px;padding:8px;border-radius:12px;background:linear-gradient(180deg, var(--card), #fbffff);border:1px solid rgba(6,50,58,0.04);box-shadow:0 2px 8px rgba(2,18,22,0.04)}
    .row:hover{box-shadow:0 8px 24px rgba(6,50,58,0.08)}
    /* prevent selection from changing layout: ensure selected rows don't alter size */
    .row.selected{transform:none !important; box-sizing:border-box;}

    /* Edit-mode specific: avoid hover/transform effects and keep actions width fixed so grid doesn't reflow */
    body.edit-mode .row{transform:none !important;transition:none !important;}
    body.edit-mode .row:hover{box-shadow:0 4px 10px rgba(6,50,58,0.06)}
    body.edit-mode .actions{min-width:110px;flex:0 0 110px}
    /* ensure action buttons don't expand the card when toggled */
    body.edit-mode .actions .small-btn{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    .icon-wrap{flex:0 0 56px;height:56px;border-radius:8px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,var(--accent-1),var(--accent-2));font-weight:700;color:#ffffff}
    .icon-wrap img{width:44px;height:44px;border-radius:8px;object-fit:cover}
  .meta{flex:1;min-width:0}
  .title{font-weight:800;font-size:16px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--text);padding-right:6px}
  .desc{font-size:13px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:6px}
    .tags{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap}
    .tag{background:#eafffb;padding:4px 8px;border-radius:999px;font-size:12px;color:var(--text);border:1px solid rgba(6,50,58,0.06);font-weight:700}

  .actions{flex:0 0 110px;display:flex;justify-content:flex-end;gap:8px}
  /* drag state visuals (removed - drag&drop feature disabled) */
    .open-btn{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:10px;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));color:#ffffff;border:none;cursor:pointer;font-weight:700;box-shadow:0 6px 18px rgba(6,50,58,0.06)}
    .open-btn:active{transform:translateY(1px)}
    .small-btn{padding:8px 10px;border-radius:8px;border:1px solid rgba(6,50,58,0.08);background:var(--card);color:var(--text);cursor:pointer;font-weight:700}

    /* floating add button (top-right) */
    .fab{
      position:fixed;right:20px;top:20px;z-index:240;width:56px;height:56px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));color:#ffffff;font-weight:900;font-size:28px;border:none;box-shadow:0 8px 24px rgba(6,50,58,0.12);cursor:pointer;
    }
    .fab:active{transform:translateY(2px)}

    /* (å‰Šé™¤æ¸ˆ) æ—§ãƒ»ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒœã‚¿ãƒ³ã¯å»ƒæ­¢ */

  /* action buttons visibility in edit mode */
  .actions{flex:0 0 110px;display:flex;justify-content:flex-end;gap:8px}
    .small-btn{padding:8px 10px;border-radius:8px;border:1px solid rgba(6,50,58,0.08);background:var(--card);color:var(--text);cursor:pointer;font-weight:700;display:none}
    body.edit-mode .small-btn{display:inline-block}
  /* hide only the per-row open button in edit mode (keep modal open/save buttons visible) */
  body.edit-mode .row .open-btn{display:none}
  /* top header buttons active state */
  .top-buttons .top-btn.active{background:linear-gradient(90deg,#ff6b6b,#ff8787);color:#ffffff;border-color:transparent}

  /* top header buttons (always visible) */
  .top-btn{padding:8px 10px;border-radius:8px;border:1px solid rgba(6,50,58,0.08);background:var(--card);color:var(--text);cursor:pointer;font-weight:700}

    /* header toggle (show on all sizes; on mobile it becomes absolute) */
    .header-toggle{display:inline-flex;margin-right:8px;background:transparent;border:1px solid rgba(6,50,58,0.06);padding:6px 8px;border-radius:8px;font-size:18px;align-items:center;justify-content:center;position:relative}
    /* è¡¨ç¤ºã‚µã‚¤ã‚ºé¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
     .view-mode-menu{position:absolute;top:48px;left:0;z-index:1020;background:var(--card);border:1px solid rgba(6,50,58,0.08);border-radius:10px;padding:10px;box-shadow:0 8px 24px rgba(2,18,22,0.12);min-width:140px}
     /* When wrapped inside the header hamburger, anchor menu to the toggle button
       so it appears inside the header instead of overlapping it. */
     #viewToggleWrap .view-mode-menu{top:calc(100% + 6px);left:0}
    .view-mode-menu .menu-title{font-weight:700;font-size:13px;color:var(--text);margin-bottom:8px;padding-bottom:6px;border-bottom:1px solid rgba(6,50,58,0.06)}
    .view-mode-menu .menu-radio{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:6px;cursor:pointer;font-size:14px;color:var(--text);transition:background 0.2s}
    .view-mode-menu .menu-radio:hover{background:rgba(6,50,58,0.04)}
    .view-mode-menu .menu-radio input[type="radio"]{cursor:pointer}
    .view-mode-menu .menu-radio input[type="radio"]:checked + span{font-weight:700;color:var(--accent-1)}

    /* è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰: smallï¼ˆæœ€å°ï¼‰ â€” ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ–: è¡Œé«˜ãƒ»ä½™ç™½ã‚’ç¸®ã‚ã¦ã‚ˆã‚Šå¤šãè¡¨ç¤º */
    .list--small .row{height:auto;min-height:32px;padding:4px 6px;gap:6px}
    .list--small .icon-wrap{flex:0 0 24px;height:24px;border-radius:4px}
    .list--small .icon-wrap img{width:20px;height:20px;border-radius:4px}
    .list--small .meta{flex:1;min-width:0}
    .list--small .title{font-size:13px;font-weight:700}
    .list--small .desc, .list--small .tags{display:none} /* èª¬æ˜ã¨ã‚¿ã‚°ã‚’éè¡¨ç¤º */
    .list--small .actions{flex:0 0 76px}
    /* å°è¡¨ç¤ºã§ç·¨é›†ãƒœã‚¿ãƒ³ã‚’ã‚ˆã‚Šã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«ã™ã‚‹ï¼ˆè¡Œã®é«˜ã•å¢—åŠ ã‚’é˜²æ­¢ï¼‰ */
    .list--small .open-btn{padding:6px 8px;font-size:12px;border-radius:6px}
    .list--small .open-btn span{display:none}

    /* è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰: mediumï¼ˆæ—¢å­˜ï¼šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰ */
    /* .list--medium .row ã¯æ—¢å­˜ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç¶™æ‰¿ã™ã‚‹ãŸã‚ã€æ˜ç¤ºçš„ãªä¸Šæ›¸ãã¯ä¸è¦ã§ã™ */

    @media(max-width:560px){
      .header-toggle{display:inline-flex}
      /* keep hamburger inline within the top-row on small screens to avoid overlapping mid-row */
      .header-toggle{width:36px;height:36px;padding:4px;border-radius:8px}
      /* collapsed by default on mobile - keep search visible while hiding other controls */
      header.card .headerInner{display:block}
      /* when collapsed, hide mid and bottom rows to simulate closed header */
      header.card.collapsed .mid-row,
      header.card.collapsed .bottom-row { display: none; }
      /* keep top-row visible */
      header.card.collapsed .top-row { display: flex; }
    }
    @media(min-width:561px){
      header.card.collapsed .headerInner{display:block}
    }

    /* On desktop, hide the old mid-row view-mode and sort controls (now available via hamburger menu) */
    @media(min-width:881px){
      .mid-row .selector{display:none}
    }

    /* modal */
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:220}
    /* ensure modal small buttons are visible regardless of edit-mode */
    .modal .small-btn{display:inline-block}
    .modal .panel{background:linear-gradient(180deg,var(--card),#fbffff);padding:18px;border-radius:12px;max-width:720px;width:92%;max-height:80vh;overflow:auto;box-shadow:0 10px 40px rgba(2,12,20,0.4);border:1px solid rgba(6,50,58,0.04)}
    .modal .panel h3{margin:0 0 8px 0;color:var(--text)}
    .form-row{display:flex;flex-direction:column;gap:6px;margin-bottom:10px}
    .form-row input, .form-row textarea{padding:10px;border-radius:8px;border:1px solid rgba(6,50,58,0.08);background:var(--card);color:var(--text);box-shadow: inset 0 1px 0 rgba(2,12,14,0.02)}
    .form-row input::placeholder, .form-row textarea::placeholder{color:#9fb5b7}
    .form-row label{color:var(--text);font-weight:700}
    .form-inline{display:flex;gap:8px;align-items:center}
    .muted-note{font-size:12px;color:var(--muted)}

    /* tag overflow control */
    .tagbar{display:flex;gap:8px;align-items:center;flex-wrap:nowrap;overflow:hidden;margin-top:10px}
    .chip{padding:8px 10px;border-radius:999px;background:#eafffb;border:1px solid rgba(6,50,58,0.06);cursor:pointer;white-space:nowrap;color:var(--text);font-weight:700;overflow:hidden;text-overflow:ellipsis;min-width:0}
    .chip.active{background:linear-gradient(90deg,var(--accent-1),var(--accent-2));color:#ffffff;border-color:transparent;font-weight:700}
    .chip-container{display:flex;gap:8px;overflow:hidden;min-width:0}
    .more-btn{padding:8px 10px;border-radius:999px;background:#eafffb;border:1px solid rgba(6,50,58,0.06);cursor:pointer;color:var(--text);font-weight:700}

    /* ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±è¡Œï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼å†…ï¼‰ */
    .user-info-row{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      padding:6px 10px;
      border-radius:8px;
      background:rgba(6,50,58,0.04);
      transition:background 0.2s;
      white-space:nowrap;
    }
    .user-info-row:hover{background:rgba(6,50,58,0.08)}
    .user-mini-avatar{
      width:28px;height:28px;border-radius:50%;background:linear-gradient(135deg,var(--accent-1),var(--accent-2));
      display:flex;align-items:center;justify-content:center;font-size:14px;color:#fff;overflow:hidden;flex-shrink:0;
    }
    .user-mini-avatar img{width:100%;height:100%;object-fit:cover;border-radius:50%}
    .user-info-text{font-size:13px;color:var(--text);font-weight:600;overflow:hidden;text-overflow:ellipsis;max-width:180px}
    @media(max-width:560px){.user-info-text{max-width:120px}}

  /* Top-row specifics: show icon only, prevent wrapping */
  .top-row{display:flex;align-items:center;justify-content:space-between;flex-wrap:nowrap;padding:4px 8px}
  .top-row .user-info-text{display:none}
  .top-row .user-mini-avatar{width:36px;height:36px}
  #authRight{margin-left:auto;flex-shrink:0}
  .top-row .search{flex:1;min-width:0;margin:0 12px}

  /* Current folder button: match tag-list style (white/pill background) */
  /* Current folder button: white/pill background similar to tag-list (slightly muted) */
  #currentFolderBtn{background:var(--card);border:1px solid rgba(6,50,58,0.06);border-radius:999px;padding:6px 8px;color:var(--text);cursor:pointer}
  #currentFolderBtn:hover{background:linear-gradient(180deg,var(--card),#fbffff);color:var(--text);box-shadow:0 6px 18px rgba(6,50,58,0.04)}
  #currentFolderBtn:active{transform:translateY(1px)}

  /* folder icon inside button */
  .folder-icon{display:inline-block;margin-right:8px;font-size:16px;line-height:1;vertical-align:middle}

  /* Keep the count/actions row visible while scrolling */
    /* make count row sticky and reduce horizontal padding to save space
      top will be set dynamically to the header height via --hdr-h */
    #count{position:sticky;top:var(--hdr-h,0px);z-index:995;padding:4px 0}
    /* subtle translucent gray background to visually separate the line */
    #count .count-row{background:rgba(6,50,58,0.18);padding:6px 6px;border-radius:0;box-shadow:none}

    /* ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« */
    .user-avatar-large{
      width:80px;height:80px;border-radius:50%;background:linear-gradient(135deg,var(--accent-1),var(--accent-2));
      display:flex;align-items:center;justify-content:center;font-size:2.5rem;color:#fff;margin:0 auto;overflow:hidden;
    }
    .user-avatar-large img{width:100%;height:100%;object-fit:cover;border-radius:50%}

    /* small screens tweaks */
    @media(max-width:560px){
      :root{--row-h:86px}
      .open-btn{padding:12px 14px}
      .icon-wrap{flex:0 0 64px;height:64px}
      .chip {padding:8px}
      header.card{padding:10px 8px}
      /* Stack header vertically on small screens for readability */
      header.card{flex-direction:column;align-items:stretch}
  .selector{width:100%;margin-top:8px}
  /* On narrow screens keep the view button compact and let the select fill remaining space */
  .selector{display:flex;gap:8px;align-items:center}
  .selector select{flex:1;min-width:0}
  .selector button{flex:0 0 auto}
  .search{width:100%}
  .search input{width:100%}
  /* ensure proper stacking order (no explicit order so layout remains stable) */
  .search{order:unset}
  .selector{order:unset}
  .top-buttons{order:unset}
      .top-buttons{display:flex;gap:8px;margin-top:8px}
      .fab{display:none}
      /* reduce action width on narrow screens to give meta more room */
      .actions{flex:0 0 96px}
      /* auth-ui ã‚’ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã« */
      #auth-ui{flex-wrap:nowrap;}
    }

    /* Prevent iOS Safari auto-zoom on input focus by ensuring tappable inputs use at least 16px font-size */
    @media(max-width:560px){
      html,body{ -webkit-text-size-adjust:100%; }
      input,select,textarea,button{ font-size:16px !important; }
      .modal .panel input, .modal .panel textarea, .modal .panel select{ font-size:16px !important; }
    }

  </style>
</head>
<body>
  <div class="wrap">
    <header class="card" role="banner">
      <div class="top-row">
        <div id="viewToggleWrap" style="position:relative;display:inline-block">
          <button id="headerToggle" class="header-toggle" aria-expanded="false" title="ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã" aria-haspopup="menu">â˜°</button>
          <!-- (æ—§) ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼å†…ã®è¡¨ç¤ºã‚µã‚¤ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¯å‰Šé™¤æ¸ˆã¿ -->
        </div>

        <div class="search" aria-hidden="false" style="flex:1;min-width:0;margin:0 12px;">
          <input id="q" placeholder="æ¤œç´¢" autocomplete="off" />
          <div class="icon">ğŸ”</div>
        </div>

        <div id="authRight" style="flex-shrink:0;z-index:1010;">
          <div class="user-info-row" id="userInfoBtn" title="ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®š">
            <div class="user-mini-avatar" id="userMiniAvatar">ğŸ‘¤</div>
            <span class="user-info-text" id="userInfoText">ãƒ¦ãƒ¼ã‚¶ãƒ¼: ã‚²ã‚¹ãƒˆ</span>
          </div>
        </div>
      </div>

      <!-- mid-row removed: display-size and sort moved to hamburger menu -->
    </header>

    <div class="content-row">
      <aside id="sidebarFolderList" class="sidebar" aria-label="ãƒ•ã‚©ãƒ«ãƒ€ä¸€è¦§">
        <!-- ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç”¨ã‚µã‚¤ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ä¸€è¦§ï¼ˆJSã§æç”»ã•ã‚Œã¾ã™ï¼‰ -->
      </aside>

      <main>
      <div id="count" style="color:var(--muted);margin:8px 0">
        <div class="count-row" style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
          <div style="display:flex;align-items:center;gap:8px;">
            <button id="currentFolderBtn" class="top-btn"><span class="folder-icon">ğŸ“</span><span class="folder-label">ã™ã¹ã¦</span></button>
            <div id="countText" style="color:var(--muted)">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
          </div>
          <div class="count-actions" style="display:flex;gap:8px;align-items:center">
            <button class="more-btn" id="moreTagsBtn" aria-haspopup="dialog">ï¼‹ã‚¿ã‚°ä¸€è¦§</button>
            <button id="topOpenAdd" class="top-btn" title="è¿½åŠ ">ï¼‹</button>
            <button id="topDeleteSelectedBtn" class="top-btn" title="é¸æŠé …ç›®ã‚’å‰Šé™¤" style="display:none;background:#e74c3c;color:#fff;border-color:#e74c3c;">å‰Šé™¤</button>
            <button id="topEditModeBtn" class="top-btn" title="é¸æŠãƒ¢ãƒ¼ãƒ‰">é¸æŠ</button>
          </div>
        </div>
      </div>
      <div class="list" id="list"></div>
      </main>
    </div>
  </div>

  
  <button class="fab" id="openAdd" title="ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’è¿½åŠ ">ï¼‹</button>

  <!-- (å‰Šé™¤) æ—§ãƒ»ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒœã‚¿ãƒ³ã¯å»ƒæ­¢ -->

  <!-- modal for adding a bookmark -->
  <div class="modal" id="addModal" role="dialog" aria-modal="true">
    <div class="panel" role="document" aria-labelledby="addTitle">
      <h3 id="addTitle">ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’è¿½åŠ </h3>

      <div class="form-row">
        <label>URLï¼ˆå¿…é ˆï¼‰</label>
        <div class="form-inline">
          <input id="addUrl" type="url" placeholder="https://example.com" style="flex:1" />
          <button id="pasteUrlBtn" class="small-btn" type="button">ãƒšãƒ¼ã‚¹ãƒˆ</button>
        </div>
      </div>

      <div class="form-row">
        <label>ã‚¿ã‚¤ãƒˆãƒ«</label>
        <input id="addTitleInput" type="text" placeholder="è‡ªå‹•å–å¾—ã•ã‚Œã¾ã™" />
      </div>

      <div class="form-row">
        <label>ã‚¢ã‚¤ã‚³ãƒ³ URLï¼ˆä»»æ„ï¼‰</label>
        <input id="addIcon" type="url" placeholder="å¤–éƒ¨ã‚¢ã‚¤ã‚³ãƒ³ URL ã‚’æŒ‡å®šï¼ˆçœç•¥å¯ï¼‰" />
      </div>
      <div class="form-row">
        <label>èª¬æ˜ï¼ˆä»»æ„ï¼‰</label>
        <textarea id="addDesc" rows="2" placeholder="ã‚µã‚¤ãƒˆã®èª¬æ˜"></textarea>
      </div>

      <div class="form-row">
        <label>ãƒ•ã‚©ãƒ«ãƒ€ï¼ˆä»»æ„ï¼‰</label>
        <select id="addFolder">
          <option value="">ï¼ˆãªã—ï¼‰</option>
        </select>
      </div>

      <div class="form-row">
        <label>ã‚¿ã‚°ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã€ä»»æ„ï¼‰</label>
        <input id="addTags" type="text" placeholder="ä¾‹: é–‹ç™º,ãƒ„ãƒ¼ãƒ«" />
      </div>

      <div style="display:flex;gap:8px;justify-content:space-between;margin-top:8px;align-items:center">
        <div style="display:flex;gap:8px;align-items:center">
          <button id="deleteInModal" class="small-btn" type="button" style="display:none;background:#e74c3c;color:#fff;border-color:#e74c3c;">å‰Šé™¤</button>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;align-items:center">
          <button id="cancelAdd" class="small-btn" type="button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
          <button id="saveAdd" class="open-btn" type="button">ä¿å­˜</button>
        </div>
      </div>
    </div>
  </div>

  <!-- modal for full tag selection -->
  <div class="modal" id="tagModal" role="dialog" aria-modal="true">
    <div class="panel">
      <h3>ã‚¿ã‚°ã§çµã‚Šè¾¼ã‚€</h3>
      <div style="margin-bottom:8px"><input id="tagSearch" placeholder="ã‚¿ã‚°ã§æ¤œç´¢" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" /></div>
      <div class="tags-grid" id="modalTags"></div>
      <div style="margin-top:12px;text-align:right"><button id="closeModal">é–‰ã˜ã‚‹</button></div>
    </div>
  </div>

  <!-- modal for folder selection -->
  <div class="modal" id="folderModal" role="dialog" aria-modal="true">
    <div class="panel" role="document" style="max-width:360px;">
      <h3 style="margin-top:0;">ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ</h3>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <input id="newFolderInput" placeholder="æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(6,50,58,0.08)" />
          <button id="addFolderBtn" class="small-btn" type="button">ä½œæˆ</button>
        </div>
      <div id="folderList" style="display:flex;flex-direction:column;gap:8px;margin-top:8px;max-height:320px;overflow:auto"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="folderRenameBtn" class="small-btn" type="button">åå‰å¤‰æ›´</button>
        <button id="folderMoveBtn" class="small-btn" type="button">ç§»å‹•</button>
        <button id="folderDeleteBtn" class="small-btn" type="button" style="background:#e74c3c;color:#fff;border-color:#e74c3c;">å‰Šé™¤</button>
        <button id="folderClose" class="small-btn" type="button">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>

  <!-- modal for view mode selection -->
  <div class="modal" id="viewModeModal" role="dialog" aria-modal="true">
    <div class="panel" role="document" style="max-width:360px;">
      <h3 style="margin-top:0;">è¡¨ç¤ºã‚µã‚¤ã‚º</h3>
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
        <label style="display:flex;align-items:center;gap:8px"><input type="radio" name="vmode" value="small"> å°</label>
        <label style="display:flex;align-items:center;gap:8px"><input type="radio" name="vmode" value="medium"> ä¸­</label>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="viewModeCancel" class="small-btn" type="button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="viewModeSave" class="open-btn" type="button">é©ç”¨</button>
      </div>
    </div>
  </div>

  <!-- JSON import/export UI removed -->

  <!-- ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div class="modal" id="userSettingsModal" role="dialog" aria-modal="true">
    <div class="panel" role="document" style="max-width:400px;">
      <h3 style="text-align:center;">ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®š</h3>
      <div style="text-align:center;margin:16px 0;">
        <div class="user-avatar-large" id="userAvatarLarge">ğŸ‘¤</div>
        <input type="file" id="avatarUploadInput" accept="image/*" style="display:none" />
        <button id="uploadAvatarBtn" class="small-btn" style="margin-top:12px;">ğŸ“· ã‚¢ã‚¤ã‚³ãƒ³ã‚’å¤‰æ›´</button>
      </div>
      <div id="loginSection" style="margin-top:16px;">
        <p style="text-align:center;color:var(--muted);font-size:13px;margin-bottom:12px;">Googleã§ãƒ­ã‚°ã‚¤ãƒ³ã™ã‚‹ã¨ãƒ‡ãƒ¼ã‚¿ãŒåŒæœŸã•ã‚Œã¾ã™</p>
        <button id="googleSignInBtn2" class="open-btn" style="width:100%;display:flex;align-items:center;justify-content:center;gap:8px;">
          <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google" style="width:18px;height:18px;">
          Googleã§ãƒ­ã‚°ã‚¤ãƒ³
        </button>
      </div>
      <div id="logoutSection" style="display:none;margin-top:16px;">
        <p id="loggedInEmail" style="text-align:center;color:var(--muted);font-size:13px;margin-bottom:12px;"></p>
        <button id="signOutBtn2" class="small-btn" style="width:100%;background:#e74c3c;color:#fff;border-color:#e74c3c;">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
      </div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:20px;">
        <!-- OGP ãƒ—ãƒ­ã‚­ã‚·è¨­å®š UI ã¯éè¡¨ç¤ºï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ Worker ã‚’åˆ©ç”¨ï¼‰ -->
        <button id="closeUserSettingsModal" class="small-btn">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>

  <!-- Firebase SDKï¼ˆcompatï¼‰: ã“ã‚Œã‚’ä¸€åº¦ã ã‘èª­ã¿è¾¼ã‚€ -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <!-- å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆæœ¬ä½“ -->
  <script>/* app.js
   - ã‚¢ãƒ—ãƒªæœ¬ä½“ï¼ˆUIå‹•ä½œã€localStorageã®æ“ä½œï¼‰
   - Realtime Database åŒæœŸï¼ˆåŒ¿åèªè¨¼ / Google ã‚µã‚¤ãƒ³ã‚¤ãƒ³ + ãƒãƒ¼ã‚¸ï¼‰
   - ã“ã‚Œ1æœ¬ã§å‹•ãã¾ã™ï¼ˆHTMLã§Firebase SDKã¯èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹å‰æï¼‰
*/

/* ------------------ åˆæœŸãƒ‡ãƒ¼ã‚¿ & ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ------------------ */
// åˆæœŸãƒ‡ãƒ¼ã‚¿ã¯ç©ºã«ã™ã‚‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’è¿½åŠ ã—ã¦åˆ©ç”¨ï¼‰
let DATA = [];

function toHiragana(str){
  if(!str) return '';
  str = str.normalize('NFKC');
  let out = '';
  for (let ch of str){
    const code = ch.charCodeAt(0);
    if (code >= 0x30A1 && code <= 0x30F4){ out += String.fromCharCode(code - 0x60); }
    else out += ch;
  }
  return out.toLowerCase();
}
function normalizeForSearch(s){ if(!s) return ''; return toHiragana(s).replace(/\s+/g,'').toLowerCase(); }

/* CSV parser removed (unused). Keep utilities small. */
function faviconFromUrl(u, size=64){
  try{ const url = new URL(u); return `https://www.google.com/s2/favicons?sz=${size}&domain=${url.hostname}`; } catch(e){ return '' }
}
function getImageProxy(imageUrl){
  // Use Worker's /img endpoint to proxy images, avoiding CORS/hotlink issues
  if(!imageUrl || !imageUrl.trim()) return '';
  try{
    const proxy = getOgpProxy(); // reuse OGP proxy base URL
    if(!proxy || !proxy.trim()) return imageUrl; // no proxy, return original
    const base = proxy.replace(/\/$/, '');
    return base + '/img?url=' + encodeURIComponent(imageUrl);
  }catch(e){ return imageUrl; }
}
/**
 * Clean/normalize titles returned from OGP/oEmbed
 * - Trim surrounding whitespace
 * - Remove common site suffixes like " - YouTube", " | YouTube", "Â· YouTube"
 * - If result is empty or only contains site name, return null
 */
function cleanTitle(t){
  if(!t) return null;
  try{
    let s = String(t).trim();
    // remove common separators and trailing site names
    s = s.replace(/^[\-\|\u00B7\s]+|[\-\|\u00B7\s]+$/g, '');
    // common patterns: "Title - YouTube", "Title | YouTube"
    s = s.replace(/\s+[\-\|\u00B7]\s+YouTube$/i, '');
    s = s.replace(/\s+[\-\|\u00B7]\s+Twitter$/i, '');
    s = s.replace(/\s+\|\s+Facebook$/i, '');
    s = s.trim();
    // if only contains 'YouTube' or host-like content, treat as empty
    if(/^youtube(?:\.com)?$/i.test(s) || /^www\.youtube\.com$/i.test(s) || s.length === 0) return null;
    return s || null;
  }catch(e){ return String(t).trim() || null; }
}

/* ------------------ state & dom refs ------------------ */
const VIEW_MODE_KEY = 'bookmark_view_mode_v1'; // localStorage ã‚­ãƒ¼
const SORT_KEY = 'bookmark_sort_v1';
const FOLDER_KEY = 'bookmark_folder_v1';
const FOLDERS_KEY = 'bookmark_folder_list_v1';
// Special folder for items without any folder assignment. Always present and not deletable.
const UNCATEGORIZED = 'æœªåˆ†é¡';
const state = { q:'', tags: new Set(), sort:'kana', editMode: false, viewMode: 'medium', selectedIds: new Set(), currentFolder: 'All' };
const el = {
  q: document.getElementById('q'),
  list: document.getElementById('list'),
  chipContainer: document.getElementById('chipContainer'),
  tagbar: document.getElementById('tagbar'),
  moreTagsBtn: document.getElementById('moreTagsBtn'),
  tagModal: document.getElementById('tagModal'),
  modalTags: document.getElementById('modalTags'),
  closeModal: document.getElementById('closeModal'),
  tagSearch: document.getElementById('tagSearch'),
  count: document.getElementById('count'),
  countText: document.getElementById('countText'),
  sort: document.getElementById('sort'),
  
  openAdd: document.getElementById('openAdd'),
  topOpenAdd: document.getElementById('topOpenAdd'),
  editModeBtn: document.getElementById('editModeBtn'),
  topEditModeBtn: document.getElementById('topEditModeBtn'),
  addModal: document.getElementById('addModal'),
  addUrl: document.getElementById('addUrl'),
  addTitleInput: document.getElementById('addTitleInput'),
  addIcon: document.getElementById('addIcon'),
  addDesc: document.getElementById('addDesc'),
  addTags: document.getElementById('addTags'),
  addFolder: document.getElementById('addFolder'),
  pasteUrlBtn: document.getElementById('pasteUrlBtn'),
  saveAdd: document.getElementById('saveAdd'),
  cancelAdd: document.getElementById('cancelAdd'),
  topDeleteSelectedBtn: document.getElementById('topDeleteSelectedBtn'),
  viewModeBtn: null,
  viewModeModal: null,
  viewModeCancel: null,
  viewModeSave: null,
  deleteInModal: document.getElementById('deleteInModal'),
  folderBtn: null,
  folderModal: null,
  folderSelectInModal: null
};

const STORAGE_KEY = 'bookmark_data_v1';
// If you run a local OGP proxy (see ogp-proxy-server), set its base URL here, e.g. 'http://localhost:3000'
// Default OGP proxy (hidden; no UI required). Set to deployed Worker.
const OGP_PROXY = 'https://ogp-proxy.kyu68002.workers.dev';
function getOgpProxy(){ try{ return (localStorage.getItem('ogp_proxy') || OGP_PROXY || '').toString(); }catch(e){ return OGP_PROXY || ''; } }
function saveToStorage(){
  try{
    // è‡ªå‹•ã§é‡è¤‡ URL ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ä¿å­˜
    try{ DATA = dedupeData(DATA || []); }catch(e){}
    localStorage.setItem(STORAGE_KEY, JSON.stringify(DATA));
    try{ renderFolderList(); }catch(e){}
  } catch(e){ console.warn('localStorage ä¿å­˜å¤±æ•—', e); }
}
// æ­£è¦åŒ–ã—ã¦æ¯”è¼ƒç”¨ã®ã‚­ãƒ¼ã‚’ä½œã‚‹ï¼ˆç°¡æ˜“ï¼‰
function normalizeUrlForCompare(u){
  try{
    let s = (u||'').toString().trim();
    if(!s) return '';
    if(!/^https?:\/\//i.test(s)) s = 'https://' + s;
    const url = new URL(s);
    // å°æ–‡å­—åŒ–ã€æœ«å°¾ã‚¹ãƒ©ãƒƒã‚·ãƒ¥å‰Šé™¤ã€ãƒãƒƒã‚·ãƒ¥é™¤å»
    url.hash = '';
    let path = url.pathname || '/';
    // remove trailing slash except when path is '/'
    if(path.length > 1 && path.endsWith('/')) path = path.replace(/\/+$/, '');
    // basic utm removal for common params
    url.searchParams.forEach((v,k)=>{ if(/^utm_/i.test(k)) url.searchParams.delete(k); });
    const norm = url.protocol + '//' + url.hostname.toLowerCase() + (path === '/' ? '' : path) + (url.search ? '?' + url.searchParams.toString() : '');
    return norm;
  }catch(e){ return (u||'').toString().trim(); }
}

// é…åˆ—å†…ã®é‡è¤‡ URL ã‚’é™¤å»ã™ã‚‹ã€‚å…ˆã«å‡ºç¾ã™ã‚‹ã‚‚ã®ã‚’æ®‹ã™ã€‚
function dedupeData(arr){
  const seen = new Set();
  const res = [];
  (arr || []).forEach(item=>{
    const key = normalizeUrlForCompare(item.url || '');
    if(!key) return; // skip malformed
    if(seen.has(key)) return; // duplicate -> skip
    seen.add(key);
    res.push(item);
  });
  return res;
}
function loadFromStorage(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){ const parsed = JSON.parse(raw); if(Array.isArray(parsed) && parsed.length) { DATA = parsed; return true; } }
  } catch(e){ console.warn('localStorage èª­ã¿è¾¼ã¿å¤±æ•—', e); }
  return false;
}

// load and dedupe: called at init to ensure duplicates removed
function loadAndDedupeFromStorage(){
  if(loadFromStorage()){
    try{ DATA = dedupeData(DATA || []); saveToStorage(); }catch(e){}
    return true;
  }
  return false;
}

/* ------------------ ã‚¿ã‚°é–¢é€£ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ------------------ */
function buildAllTags(data){
  return Array.from(new Set((data || []).flatMap(d=>(d.tags || [])))).sort((a,b)=>a.localeCompare(b,'ja'));
}
function buildAllFolders(data){
  const set = new Set();
  // add folders from data (explicit folder names)
  (data || []).forEach(d=>{ if(d && d.folder) set.add(d.folder); });
  // also include user-created (possibly empty) folders saved separately
  try{
    const raw = localStorage.getItem(FOLDERS_KEY);
    if(raw){ const parsed = JSON.parse(raw); if(Array.isArray(parsed)) parsed.forEach(f=>{ if(f) set.add(f); }); }
  }catch(e){ /* ignore */ }
  // ensure UNCATEGORIZED is available for display (items with no folder)
  set.delete('All'); // don't include 'All' as a stored folder
  // Sort hierarchically: split by /, compare each segment
  const arr = Array.from(set).sort((a,b)=>{
    const aParts = a.split('/');
    const bParts = b.split('/');
    for(let i=0; i<Math.max(aParts.length, bParts.length); i++){
      if(i >= aParts.length) return -1;
      if(i >= bParts.length) return 1;
      const cmp = aParts[i].localeCompare(bParts[i], 'ja');
      if(cmp !== 0) return cmp;
    }
    return 0;
  });
  // Remove any folders defined under the special UNCATEGORIZED prefix (not allowed)
  const sanitized = arr.filter(f => !f.startsWith(UNCATEGORIZED + '/'));
  // Always present: top-level 'All' (ã™ã¹ã¦) and 'æœªåˆ†é¡'
  return ['All', UNCATEGORIZED, ...sanitized.filter(f => f !== UNCATEGORIZED)];
}

function getFolderDepth(path){
  // Treat 'All' as depth 1 per user request
  if(!path) return 0;
  if(path === 'All') return 1;
  if(path === UNCATEGORIZED) return 1;
  return path.split('/').length + 0; // segments count (root=1)
}

// Return a visible tree prefix for a given depth. Examples:
// depth=1 -> ''
// depth=2 -> 'â””â”€ '
// depth=3 -> 'â”‚ â””â”€ '
// (removed getFolderPrefix helper; use simple full-width space indentation)

function getParentFolder(path){
  if(!path || path === 'All') return 'All';
  const parts = path.split('/');
  if(parts.length <= 1) return 'All';
  parts.pop();
  return parts.join('/');
}

function getFolderName(path){
  if(!path || path === 'All') return 'ã™ã¹ã¦';
  if(path === UNCATEGORIZED) return UNCATEGORIZED;
  const parts = path.split('/');
  return parts[parts.length - 1];
}

function loadFoldersList(){
  try{
    const raw = localStorage.getItem(FOLDERS_KEY);
    if(!raw) return [];
    const parsed = JSON.parse(raw);
    if(Array.isArray(parsed)) return parsed;
  }catch(e){ console.warn('loadFoldersList failed', e); }
  return [];
}

function saveFoldersList(arr){
  try{ localStorage.setItem(FOLDERS_KEY, JSON.stringify(Array.from(new Set(arr || [])))); }catch(e){ console.warn('saveFoldersList failed', e); }
}

function createNewFolder(name, parentPath){
  try{
    const n = (name || '').toString().trim();
    if(!n) return false;
    if(n === 'All' || n === UNCATEGORIZED || n.includes('/')) return false;
    // Prevent creating a folder under UNCATEGORIZED; treat as root
    if(parentPath === UNCATEGORIZED) parentPath = null;
    const fullPath = (parentPath && parentPath !== 'All') ? parentPath + '/' + n : n;
    // Enforce max depth = 3 (All is depth 1)
    const depth = getFolderDepth(fullPath);
    if(depth > 3){
      console.warn('createNewFolder: depth limit exceeded', depth);
      return false;
    }
    const existing = buildAllFolders(DATA).filter(x=>x !== 'All');
    if(existing.includes(fullPath)) return false;
    const list = loadFoldersList(); list.push(fullPath);
    saveFoldersList(list);
    renderFolderList();
    // update add modal select options if open
    try{
      if(el.addFolder){
        const o = document.createElement('option');
        o.value = fullPath;
        const depth = getFolderDepth(fullPath);
        o.textContent = 'ã€€'.repeat(Math.max(0, depth-1)) + getFolderName(fullPath);
        el.addFolder.appendChild(o);
      }
    }catch(e){}
    return fullPath;
  }catch(e){ console.warn('createNewFolder error', e); return false; }
}

function updateFolderUI(){
  try{
    if(el.currentFolderBtn){
      const path = state.currentFolder || 'All';
      let label = '';
      if(path === 'All'){
        label = 'ã™ã¹ã¦';
      } else {
        // show only the current folder (leaf)
        const leaf = getFolderName(path);
        // truncate after 4 characters, show ellipsis from 5th onward
        label = (leaf && leaf.length > 4) ? leaf.slice(0,4) + 'â€¦' : (leaf || '');
      }
      try{
        // keep the folder icon, show truncated label, full path in title for tooltip
        el.currentFolderBtn.innerHTML = '<span class="folder-icon">ğŸ“</span><span class="folder-label">' + label + '</span>';
        el.currentFolderBtn.title = path === 'All' ? 'ã™ã¹ã¦' : path;
      }catch(e){}
    }
  }catch(e){}
}

function renderFolderList(){
  try{
    const all = buildAllFolders(DATA);
    const container = document.getElementById('folderList');
    const sidebar = document.getElementById('sidebarFolderList');
    if(!container && !sidebar) return;
    if(container) container.innerHTML = '';
    if(sidebar) sidebar.innerHTML = '';
    
    // Track expanded state
    if(!window.folderExpandedState) window.folderExpandedState = new Set();
    
    // helper to build a folder row (so we can render into both modal and sidebar)
    function buildRowForFolder(f){
      const depth = getFolderDepth(f);
      const name = getFolderName(f);
      const hasChildren = all.some(x => x !== f && x.startsWith(f + '/'));

      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '4px';
      // For top-level special folders ('All' and UNCATEGORIZED), align to left edge (no indent)
      const pad = (f === 'All' || f === UNCATEGORIZED) ? 0 : Math.max(0, (depth - 1)) * 16;
      row.style.paddingLeft = pad + 'px';
      row.style.marginBottom = '4px';

      if(hasChildren){
        const toggle = document.createElement('span');
        toggle.style.cursor = 'pointer';
        toggle.style.fontSize = '12px';
        toggle.style.width = '16px';
        toggle.textContent = window.folderExpandedState.has(f) ? 'â–¼' : 'â–¶';
        toggle.addEventListener('click', (e)=>{ e.stopPropagation(); if(window.folderExpandedState.has(f)) window.folderExpandedState.delete(f); else window.folderExpandedState.add(f); renderFolderList(); });
        row.appendChild(toggle);
      } else {
        const spacer = document.createElement('span');
        // If this is a top-level special folder, don't reserve spacer width
        spacer.style.width = (f === 'All' || f === UNCATEGORIZED) ? '0px' : '16px';
        row.appendChild(spacer);
      }

      // hide if parent collapsed
      if(f !== 'All'){
        const parent = getParentFolder(f);
        if(parent !== 'All' && !window.folderExpandedState.has(parent)){
          return null;
        }
      }

      const btn = document.createElement('button');
      btn.className = 'chip'; btn.style.flex = '1'; btn.style.textAlign = 'left';
      let count = 0;
      try{
        if(f === 'All') count = (DATA || []).length;
        else if(f === UNCATEGORIZED) count = (DATA || []).filter(d => !(d.folder && String(d.folder).trim())).length;
        else count = (DATA || []).filter(d => { const fld = (d.folder || '').toString(); if(!fld) return false; return fld === f || fld.startsWith(f + '/'); }).length;
      }catch(e){}
      btn.textContent = name + (count ? ` (${count})` : ' (0)');
      if(state.currentFolder === f) btn.classList.add('active');
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        // Select folder
        state.currentFolder = f; saveFolder(); updateFolderUI(); renderList();
        try{ if(el.addFolder) el.addFolder.value = state.currentFolder && state.currentFolder !== 'All' ? state.currentFolder : ''; }catch(e){}
        // If folder has children, toggle expanded state as well so tapping the folder opens/closes subtree
        try{
          if(hasChildren){
            if(window.folderExpandedState.has(f)) window.folderExpandedState.delete(f);
            else window.folderExpandedState.add(f);
          }
        }catch(err){}
        // re-render folder list to reflect expanded state
        renderFolderList();
      });

      // clicking on row toggles expand (including when clicking the row area)
      row.addEventListener('click', (e)=>{ try{ if(hasChildren){ if(window.folderExpandedState.has(f)) window.folderExpandedState.delete(f); else window.folderExpandedState.add(f); renderFolderList(); } }catch(err){} });
      row.appendChild(btn);
      return row;
    }

    all.forEach(f=>{
      const rowForModal = buildRowForFolder(f);
      if(!rowForModal) return;
      if(container) container.appendChild(rowForModal);
      // build a separate row for sidebar so event listeners and styles are fresh
      if(sidebar){
        const rowForSidebar = buildRowForFolder(f);
        if(rowForSidebar) sidebar.appendChild(rowForSidebar);
      }
    });
  }catch(e){ console.warn('renderFolderList failed', e); }
}

function saveFolder(){ try{ localStorage.setItem(FOLDER_KEY, state.currentFolder || 'All'); }catch(e){} }
function loadFolder(){ try{ const v = localStorage.getItem(FOLDER_KEY); if(v) state.currentFolder = v; }catch(e){} }
function renderTags(){
  const all = buildAllTags(DATA);
  const showN = 8;
  try{
    if(el.chipContainer){
      el.chipContainer.innerHTML = '';
      all.slice(0,showN).forEach(t=>{
        const count = DATA.filter(d=> (d.tags||[]).includes(t)).length;
        const chip = document.createElement('button');
        chip.className = 'chip' + (state.tags.has(t) ? ' active' : '');
        chip.textContent = `${t} (${count})`;
        chip.addEventListener('click', ()=>{ if(state.tags.has(t)) state.tags.delete(t); else state.tags.add(t); renderTags(); renderList(); });
        el.chipContainer.appendChild(chip);
      });
    }
    const remaining = Math.max(0, all.length - showN);
    if(el.moreTagsBtn) el.moreTagsBtn.textContent = remaining>0 ? `ï¼‹ã‚¿ã‚°ä¸€è¦§ï¼ˆã‚ã¨ ${remaining} ä»¶ï¼‰` : 'ï¼‹ã‚¿ã‚°ä¸€è¦§';
    renderModalTags(all);
  }catch(e){ console.warn('renderTags error', e); }
}
function renderModalTags(all){
  try{
    if(!el.modalTags) return;
    el.modalTags.innerHTML = '';
    all.forEach(t=>{
      const count = DATA.filter(d=> (d.tags||[]).includes(t)).length;
      const cb = document.createElement('button');
      cb.className = 'chip' + (state.tags.has(t) ? ' active' : '');
      cb.textContent = `${t} (${count})`;
      cb.addEventListener('click', ()=>{ if(state.tags.has(t)) state.tags.delete(t); else state.tags.add(t); renderModalTags(all); renderTags(); renderList(); });
      el.modalTags.appendChild(cb);
    });
  }catch(e){ console.warn('renderModalTags error', e); }
}

/* ------------------ ãƒ•ã‚£ãƒ«ã‚¿ãƒ»ã‚½ãƒ¼ãƒˆãƒ»ãƒªã‚¹ãƒˆè¡¨ç¤º ------------------ */
function filterAndSort(){
  const qn = normalizeForSearch(state.q);
  let arr = (DATA || []).filter(item=>{
    const inName = normalizeForSearch(item.title).includes(qn);
    const inUrl = normalizeForSearch(item.url).includes(qn);
    const inDesc = normalizeForSearch(item.desc||'').includes(qn);
    const tagsMatch = Array.from(state.tags).every(t=>(item.tags||[]).includes(t));
    return (qn === '' || inName || inUrl || inDesc) && tagsMatch;
  });

  // Folder filter: if a specific folder is selected (not 'All'), filter items
  try{
    if(state.currentFolder && state.currentFolder !== 'All'){
      // Special handling for "æœªåˆ†é¡" (UNCATEGORIZED): items that have no folder (empty/undefined)
      if(state.currentFolder === UNCATEGORIZED){
        arr = arr.filter(it => !(it.folder && String(it.folder).trim()));
      } else {
        arr = arr.filter(it => (it.folder || '') === state.currentFolder);
      }
    }
  }catch(e){/* ignore */}

  if(state.sort === 'kana' || state.sort === 'kana-desc'){
    const coll = new Intl.Collator('ja');
    arr.sort((a,b)=>coll.compare(toHiragana(a.title), toHiragana(b.title)));
    if(state.sort === 'kana-desc') arr.reverse();
  } else if(state.sort === 'name'){
    arr.sort((a,b)=>a.title.localeCompare(b.title,'en'));
  } else if(state.sort === 'date-new'){
    arr.sort((a,b)=> (b.created_at || 0) - (a.created_at || 0));
  } else if(state.sort === 'date-old'){
    arr.sort((a,b)=> (a.created_at || 0) - (b.created_at || 0));
  }
  return arr;
}

function renderList(){
  const arr = filterAndSort();
  el.list.innerHTML = '';
  if(el.countText) el.countText.textContent = `${arr.length} ä»¶`;

  // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ list è¦ç´ ã«ã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸
  el.list.className = 'list';
  if(state.viewMode === 'small') el.list.classList.add('list--small');
  else el.list.classList.add('list--medium');

  arr.forEach(item=>{
    const row = document.createElement('div'); row.className = 'row';

    const iconWrap = document.createElement('div'); iconWrap.className = 'icon-wrap';
    // If in edit mode, show a checkbox for multi-select
    if(state.editMode){
      const cb = document.createElement('input'); cb.type = 'checkbox'; cb.className = 'row-selector';
      cb.checked = state.selectedIds.has(item.id);
      cb.addEventListener('click', (e)=>{
        e.stopPropagation();
        if(cb.checked) state.selectedIds.add(item.id); else state.selectedIds.delete(item.id);
        // update header controls and re-render to reflect URL hiding when selected
        updateHeaderControls();
        renderList();
      });
      iconWrap.appendChild(cb);
    }
    // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ¥ã®ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤º:
    // - small / medium: å¸¸ã«ãƒ•ã‚¡ãƒ“ã‚³ãƒ³ã‚’è¡¨ç¤º
    // - large: OGP ã®ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆitem.icon_urlï¼‰ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°ãƒ•ã‚¡ãƒ“ã‚³ãƒ³
    // large view disabled: always show favicon for small/medium
    if(false && state.viewMode === 'large' && item.icon_url){
      const img = document.createElement('img');
      img.src = getImageProxy(item.icon_url);
      img.alt = item.title + ' ã‚¢ã‚¤ã‚³ãƒ³';
      img.onerror = ()=>{ img.src = faviconFromUrl(item.url,64); };
      iconWrap.appendChild(img);
    } else {
      const img = document.createElement('img');
      img.src = faviconFromUrl(item.url,64);
      img.alt = item.title ? item.title + ' ãƒ•ã‚¡ãƒ“ã‚³ãƒ³' : 'ãƒ•ã‚¡ãƒ“ã‚³ãƒ³';
      img.onerror = ()=>{ iconWrap.textContent = item.title ? item.title[0] : 'ğŸ”—'; };
      iconWrap.appendChild(img);
    }

    const meta = document.createElement('div'); meta.className = 'meta';
    const title = document.createElement('div'); title.className = 'title'; title.textContent = item.title;
    // show url below title in edit mode for clarity
    // Show URL only when in selection (edit) mode
    if(state.editMode){
      const urlEl = document.createElement('div'); urlEl.className = 'small muted'; urlEl.textContent = item.url; meta.appendChild(urlEl);
    }

    // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ¥ã®ã‚¿ã‚¤ãƒˆãƒ«è¡Œ: large ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚¿ã‚¤ãƒˆãƒ«ã®å·¦ã«ãƒ•ã‚¡ãƒ“ã‚³ãƒ³ã‚’è¡¨ç¤º
    // large view disabled: use medium flow
    if(false){
      const titleRow = document.createElement('div');
      titleRow.style.display = 'flex';
      titleRow.style.alignItems = 'center';
      titleRow.style.gap = '8px';
      // favicon ã‚’å°ã•ãè¡¨ç¤ºï¼ˆOGP ã‚¢ã‚¤ã‚³ãƒ³ã¨ã¯åˆ¥ã«ãƒ•ã‚¡ãƒ“ã‚³ãƒ³ï¼‰
      const fav = document.createElement('img');
      fav.src = faviconFromUrl(item.url, 32);
      fav.alt = 'favicon';
      fav.style.width = '20px';
      fav.style.height = '20px';
      fav.style.borderRadius = '4px';
      fav.onerror = ()=>{ fav.style.display = 'none'; };
      titleRow.appendChild(fav);
      titleRow.appendChild(title);
      // small ãƒ¢ãƒ¼ãƒ‰ã§ã¯ desc ã¨ tags ã‚’ç”Ÿæˆã—ãªã„ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–ï¼‰
      if(state.viewMode !== 'small'){
        const desc = document.createElement('div'); desc.className = 'desc'; desc.textContent = item.desc || '';
        const tagsWrap = document.createElement('div'); tagsWrap.className = 'tags';
        (item.tags || []).forEach(t=>{ const s=document.createElement('span'); s.className='tag'; s.textContent=t; tagsWrap.appendChild(s); });
        meta.appendChild(titleRow); meta.appendChild(desc); meta.appendChild(tagsWrap);
      } else {
        meta.appendChild(titleRow);
      }
    } else {
      // small / medium ã®æ—¢å­˜ãƒ•ãƒ­ãƒ¼
      if(state.viewMode !== 'small'){
        const desc = document.createElement('div'); desc.className = 'desc'; desc.textContent = item.desc || '';
        const tagsWrap = document.createElement('div'); tagsWrap.className = 'tags';
        (item.tags || []).forEach(t=>{ const s=document.createElement('span'); s.className='tag'; s.textContent=t; tagsWrap.appendChild(s); });
        meta.appendChild(title); meta.appendChild(desc); meta.appendChild(tagsWrap);
      } else {
        meta.appendChild(title);
      }
    }

    const actions = document.createElement('div'); actions.className = 'actions';
    const btn = document.createElement('button'); btn.className = 'open-btn'; btn.setAttribute('aria-label', item.title + ' ã‚’ç·¨é›†ã™ã‚‹');
    btn.innerHTML = 'ç·¨é›† <span style="opacity:0.85">âœ</span>';
    btn.addEventListener('click', (e)=>{ e.stopPropagation(); openEdit(item); btn.animate([{transform:'scale(1)'},{transform:'scale(0.98)'}],{duration:120,fill:'forwards'}); });

    const del = document.createElement('button'); del.className='small-btn'; del.textContent='å‰Šé™¤';
    del.addEventListener('click',(e)=>{ e.stopPropagation(); if(confirm('ã“ã®ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')){ DATA = DATA.filter(d=>d.id !== item.id); saveToStorage(); renderTags(); renderList(); saveBookmarksToRemote(); } });

    const edit = document.createElement('button'); edit.className='small-btn'; edit.textContent='ç·¨é›†';
    edit.addEventListener('click',(e)=>{ e.stopPropagation(); openEdit(item); });

    // keep visible; this button now opens the edit modal
    btn.style.display = '';

    if(!state.editMode){
      actions.appendChild(edit);
      actions.appendChild(del);
    }
    actions.appendChild(btn);

    iconWrap.style.cursor = 'default';
    iconWrap.draggable = false;

    row.appendChild(iconWrap); row.appendChild(meta); row.appendChild(actions);
    // è¡Œã‚¯ãƒªãƒƒã‚¯ã§åˆ¥ã‚¿ãƒ–ã§é–‹ãï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã‚„é¸æŠãƒ¢ãƒ¼ãƒ‰ã§ãªã„å ´åˆï¼‰
    row.addEventListener('click', (e) => {
      // In edit mode: tapping anywhere toggles selection
      if (state.editMode){
        const isSelected = state.selectedIds.has(item.id);
        if(isSelected) state.selectedIds.delete(item.id); else state.selectedIds.add(item.id);
        updateHeaderControls();
        renderList();
        return;
      }
      // If some items are selected (but not in edit mode), prevent navigation
      if (state.selectedIds && state.selectedIds.size > 0) return;
      try{
        if(item && item.url){ window.open(item.url, '_blank', 'noopener'); }
      }catch(e){}
    });
    el.list.appendChild(row);
  });

  if(arr.length === 0) el.list.innerHTML = '<div style="color:var(--muted)">è©²å½“ã™ã‚‹ãƒªãƒ³ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>';
}

/* ------------------ ç·¨é›†ãƒ•ãƒ­ãƒ¼ ------------------ */
function openEdit(item){
  openAddModal();
  el.addUrl.value = item.url;
  el.addTitleInput.value = item.title;
  el.addIcon.value = item.icon_url || '';
  el.addDesc.value = item.desc || '';
  el.addTags.value = (item.tags || []).join(',');
  try{ if(el.addFolder) el.addFolder.value = item.folder || ''; }catch(e){}
  el.saveAdd.dataset.editId = item.id;
  try{ if(el.deleteInModal) el.deleteInModal.style.display = 'inline-block'; }catch(e){}
}

/* ------------------ è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆæœŸåŒ– ------------------ */
function loadViewMode(){
  try{
    const saved = localStorage.getItem(VIEW_MODE_KEY);
    if(saved){
      if(['small','medium'].includes(saved)) state.viewMode = saved;
      else if(saved === 'large') state.viewMode = 'medium'; // fallback: large disabled
    }
  }catch(e){ console.warn('viewMode load failed', e); }
}
// saveViewMode defined earlier; keep single implementation

function loadSort(){
  try{
    const s = localStorage.getItem(SORT_KEY);
    if(s && typeof s === 'string'){
      state.sort = s;
    }
    // update select UI if present
    try{ if(el && el.sort) el.sort.value = state.sort; }catch(e){}
  }catch(e){ console.warn('loadSort failed', e); }
}

function saveSort(){
  try{ localStorage.setItem(SORT_KEY, state.sort); }catch(e){}
}
function saveViewMode(){
  try{ localStorage.setItem(VIEW_MODE_KEY, state.viewMode); }catch(e){}
}
// Update header controls visibility based on edit mode and selection
function updateHeaderControls(){
  try{
    const hasSelection = (state.selectedIds && state.selectedIds.size > 0);
    if(el.topDeleteSelectedBtn) el.topDeleteSelectedBtn.style.display = (hasSelection || state.editMode) ? 'inline-block' : 'none';
    if(el.topOpenAdd) el.topOpenAdd.style.display = hasSelection ? 'none' : (state.editMode ? 'none' : 'inline-block');
    if(el.openAdd) el.openAdd.style.display = hasSelection ? 'none' : '';
    if(el.topEditModeBtn) el.topEditModeBtn.classList.toggle('active', state.editMode);
    if(el.editModeBtn) el.editModeBtn.classList.toggle('active', state.editMode);
  }catch(e){/* ignore */}
}

function updateViewModeUI(){
  const radios = document.querySelectorAll('.view-mode-menu input[type="radio"]');
  radios.forEach(r=>{
    r.checked = (r.value === state.viewMode);
    const label = r.closest('.menu-radio');
    if(label) label.setAttribute('aria-checked', r.checked ? 'true' : 'false');
  });
}

/* ------------------ ã‚¤ãƒ™ãƒ³ãƒˆãƒ¯ã‚¤ãƒ¤ãƒªãƒ³ã‚° ------------------ */
el.q.addEventListener('input', ()=>{ state.q = el.q.value; renderList(); });
if(el.sort){ el.sort.addEventListener('change', ()=>{ state.sort = el.sort.value; saveSort(); renderList(); }); }

// è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰é¸æŠã‚¤ãƒ™ãƒ³ãƒˆ: æ—§ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¯å‰Šé™¤ã€‚ãƒ¢ãƒ¼ãƒ€ãƒ«ã§é¸æŠã—ã¾ã™ã€‚

// Initialize view mode modal/button elements
setTimeout(()=>{
  try{
    el.viewModeBtn = document.getElementById('viewModeBtn');
    el.viewModeModal = document.getElementById('viewModeModal');
    el.viewModeCancel = document.getElementById('viewModeCancel');
    el.viewModeSave = document.getElementById('viewModeSave');
    if(el.viewModeBtn) el.viewModeBtn.addEventListener('click', ()=>{ if(el.viewModeModal) el.viewModeModal.style.display='flex'; const radios = document.getElementsByName('vmode'); radios.forEach && radios.forEach(r=> r.checked = (r.value === state.viewMode)); });
    if(el.viewModeCancel) el.viewModeCancel.addEventListener('click', ()=>{ if(el.viewModeModal) el.viewModeModal.style.display='none'; });
    if(el.viewModeSave) el.viewModeSave.addEventListener('click', ()=>{
      const radios = document.getElementsByName('vmode'); let sel = 'medium';
      for(let i=0;i<radios.length;i++){ if(radios[i].checked) { sel = radios[i].value; break; } }
      // 'large' option was removed; no special fallback required
      state.viewMode = sel; saveViewMode(); updateViewModeUI(); renderList(); if(el.viewModeModal) el.viewModeModal.style.display='none';
    });
  }catch(e){ console.warn('viewMode modal init failed', e); }
}, 50);

// Initialize folder button & modal
setTimeout(()=>{
  try{
    el.currentFolderBtn = document.getElementById('currentFolderBtn');
    el.folderModal = document.getElementById('folderModal');
    // Reflect stored current folder in the UI now that the button element exists
    try{ loadFolder(); updateFolderUI(); }catch(e){}
    const folderClose = document.getElementById('folderClose');
    if(el.currentFolderBtn) el.currentFolderBtn.addEventListener('click', ()=>{ renderFolderList(); if(el.folderModal) el.folderModal.style.display='flex'; });
    if(folderClose) folderClose.addEventListener('click', ()=>{ if(el.folderModal) el.folderModal.style.display='none'; });
    // new folder creation UI
    try{
      const addBtn = document.getElementById('addFolderBtn');
      const input = document.getElementById('newFolderInput');
      if(addBtn && input){
        addBtn.addEventListener('click', ()=>{
          const name = input.value && input.value.trim();
          if(!name){ alert('ãƒ•ã‚©ãƒ«ãƒ€åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
          if(name.includes('/')){ alert('ãƒ•ã‚©ãƒ«ãƒ€åã« / ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“'); return; }
          const parent = (state.currentFolder && state.currentFolder !== 'All' && state.currentFolder !== UNCATEGORIZED) ? state.currentFolder : null;
          // check depth before creating
          const tentative = (parent ? parent + '/' + name : name);
          if(getFolderDepth(tentative) > 3){ alert('ãƒ•ã‚©ãƒ«ãƒ€ã®æœ€å¤§æ·±ã•ã¯ 3 ã§ã™'); return; }
          const fullPath = createNewFolder(name, parent);
          if(fullPath){
            input.value = '';
            state.currentFolder = fullPath;
            saveFolder();
            updateFolderUI();
            renderList();
            // keep modal open per user request
            try{ if(el.addFolder) el.addFolder.value = state.currentFolder && state.currentFolder !== 'All' ? state.currentFolder : ''; }catch(e){}
            renderFolderList();
          }
          else { alert('ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸï¼ˆæ—¢ã«å­˜åœ¨ã™ã‚‹ã‹ç„¡åŠ¹ãªåå‰ã§ã™ï¼‰'); }
        });
        input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); addBtn.click(); } });
      }
    }catch(e){ console.warn('folder create UI wire failed', e); }
    // folder rename/delete wiring
    try{
      const renameBtn = document.getElementById('folderRenameBtn');
      const deleteBtn = document.getElementById('folderDeleteBtn');
      if(renameBtn){
        renameBtn.addEventListener('click', ()=>{
          const cur = state.currentFolder || 'All';
          if(!cur || cur === 'All'){ alert('ã€Œã™ã¹ã¦ã€ã¯åå‰å¤‰æ›´ã§ãã¾ã›ã‚“'); return; }
          if(cur === UNCATEGORIZED){ alert('ã€Œæœªåˆ†é¡ã€ã¯åå‰å¤‰æ›´ã§ãã¾ã›ã‚“'); return; }
          const leaf = getFolderName(cur);
          const parent = getParentFolder(cur);
          const name = prompt('ãƒ•ã‚©ãƒ«ãƒ€åã‚’å¤‰æ›´', leaf);
          if(name === null) return; // cancel
          const newName = (name||'').toString().trim();
          if(!newName){ alert('ç©ºã®åå‰ã¯è¨±å¯ã•ã‚Œã¾ã›ã‚“'); return; }
          if(newName.includes('/')){ alert('ãƒ•ã‚©ãƒ«ãƒ€åã« / ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“'); return; }
          const newFull = (parent && parent !== 'All') ? parent + '/' + newName : newName;
          if(getFolderDepth(newFull) > 3){ alert('ãƒ•ã‚©ãƒ«ãƒ€ã®æœ€å¤§æ·±ã•ã¯ 3 ã§ã™'); return; }
          const existing = buildAllFolders(DATA).filter(x=>x !== 'All');
          if(existing.includes(newFull)){ alert('åŒåã®ãƒ•ã‚©ãƒ«ãƒ€ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™'); return; }
          const list = loadFoldersList();
          const newList = list.map(f => {
            if(f === cur) return newFull;
            if(f.startsWith(cur + '/')) return newFull + f.slice(cur.length);
            return f;
          });
          saveFoldersList(newList);
          // update addFolder select options if present
          try{
            if(el.addFolder){
              el.addFolder.innerHTML = '';
              const empty = document.createElement('option'); empty.value=''; empty.textContent='ï¼ˆãªã—ï¼‰'; el.addFolder.appendChild(empty);
              const foldersAll = buildAllFolders(DATA);
              foldersAll.forEach(f=>{ if(f==='All') return; const o=document.createElement('option'); o.value=f; const depth=getFolderDepth(f); o.textContent = 'ã€€'.repeat(Math.max(0,depth-1)) + getFolderName(f); el.addFolder.appendChild(o); });
              el.addFolder.value = state.currentFolder && state.currentFolder !== 'All' ? state.currentFolder : '';
            }
          }catch(e){}
          (DATA || []).forEach(it=>{
            if(!it || !it.folder) return;
            if(it.folder === cur) it.folder = newFull;
            else if(it.folder.startsWith(cur + '/')) it.folder = newFull + it.folder.slice(cur.length);
          });
          saveToStorage();
          state.currentFolder = newFull;
          saveFolder();
          updateFolderUI();
          renderFolderList();
          renderList();
        });
      }
      if(deleteBtn){
        deleteBtn.addEventListener('click', ()=>{
          const cur = state.currentFolder || 'All';
          if(!cur || cur === 'All' || cur === UNCATEGORIZED){ alert('ã€Œã™ã¹ã¦ã€ãŠã‚ˆã³ã€Œæœªåˆ†é¡ã€ã¯å‰Šé™¤ã§ãã¾ã›ã‚“'); return; }
          if(!confirm(`ãƒ•ã‚©ãƒ«ãƒ€ã€Œ${cur}ã€ã¨ãã®ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚`)) return;
          const list = loadFoldersList();
          const newList = list.filter(f => !(f === cur || f.startsWith(cur + '/')));
          saveFoldersList(newList);
          try{
            if(el.addFolder){
              el.addFolder.innerHTML = '';
              const empty = document.createElement('option'); empty.value=''; empty.textContent='ï¼ˆãªã—ï¼‰'; el.addFolder.appendChild(empty);
              const foldersAll = buildAllFolders(DATA);
              foldersAll.forEach(f=>{ if(f==='All') return; const o=document.createElement('option'); o.value=f; const depth=getFolderDepth(f); o.textContent = 'ã€€'.repeat(Math.max(0,depth-1)) + (depth>1 ? 'â”” ' : '') + getFolderName(f); el.addFolder.appendChild(o); });
              el.addFolder.value = state.currentFolder && state.currentFolder !== 'All' ? state.currentFolder : '';
            }
          }catch(e){}
          (DATA || []).forEach(it=>{
            if(!it || !it.folder) return;
            if(it.folder === cur || it.folder.startsWith(cur + '/')) it.folder = '';
          });
          saveToStorage();
          const parent = getParentFolder(cur) || 'All';
          state.currentFolder = parent;
          saveFolder();
          updateFolderUI();
          renderFolderList();
          renderList();
        });
      }
      // folder move wiring
      try{
        const moveBtn = document.getElementById('folderMoveBtn');
        if(moveBtn){
          moveBtn.addEventListener('click', ()=>{
            const cur = state.currentFolder || 'All';
            if(!cur || cur === 'All' || cur === UNCATEGORIZED){ alert('ã€Œã™ã¹ã¦ã€ãŠã‚ˆã³ã€Œæœªåˆ†é¡ã€ã¯ç§»å‹•ã§ãã¾ã›ã‚“'); return; }
            const leaf = getFolderName(cur);
            // candidates: exclude All, UNCATEGORIZED, current, and descendants
            const candidates = buildAllFolders(DATA).filter(f => f !== 'All' && f !== UNCATEGORIZED && f !== cur && !f.startsWith(cur + '/'));
            let lines = ['0: ã™ã¹ã¦'];
            candidates.forEach((f,i)=> lines.push((i+1) + ': ' + f));
            const sel = prompt('ç§»å‹•å…ˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ç•ªå·ã§é¸æŠã—ã¦ãã ã•ã„ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ä¸­æ­¢ï¼‰\n' + lines.join('\n'));
            if(sel === null) return;
            const idx = parseInt(sel, 10);
            if(isNaN(idx) || idx < 0 || idx > candidates.length){ alert('ç„¡åŠ¹ãªé¸æŠã§ã™'); return; }
            const destParent = idx === 0 ? 'All' : candidates[idx - 1];
            const newFull = destParent === 'All' ? leaf : destParent + '/' + leaf;
            if(getFolderDepth(newFull) > 3){ alert('ç§»å‹•å…ˆã«ã‚ˆã‚Šæ·±ã•åˆ¶é™ã‚’è¶…ãˆã¾ã™'); return; }
            const existing = buildAllFolders(DATA).filter(x=>x !== 'All' && x !== UNCATEGORIZED);
            if(existing.includes(newFull)){ alert('ç§»å‹•å…ˆã«åŒåã®ãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã—ã¾ã™'); return; }
            const list = loadFoldersList();
            const newList = list.map(f => {
              if(f === cur) return newFull;
              if(f.startsWith(cur + '/')) return newFull + f.slice(cur.length);
              return f;
            });
            saveFoldersList(newList);
            // update DATA items
            (DATA || []).forEach(it=>{
              if(!it || !it.folder) return;
              if(it.folder === cur) it.folder = newFull;
              else if(it.folder.startsWith(cur + '/')) it.folder = newFull + it.folder.slice(cur.length);
            });
            saveToStorage();
            state.currentFolder = newFull;
            saveFolder();
            updateFolderUI();
            renderFolderList();
            renderList();
          });
        }
      }catch(e){ console.warn('folder move wire failed', e); }
    }catch(e){ console.warn('folder rename/delete wire failed', e); }
    
    
  }catch(e){ console.warn('folder init failed', e); }
}, 80);

// ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ã®æ—¢å®šã®å‹•ä½œã¯ä¿æŒã—ã¾ã™ãŒã€æ—§ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¯å‰Šé™¤æ¸ˆã¿ã§ã™ã€‚
const headerToggleBtn = document.getElementById('headerToggle');
if(headerToggleBtn){
  headerToggleBtn.addEventListener('click', (e)=>{ e.stopPropagation(); /* reserved */ });
}

function toggleEditMode(){
  state.editMode = !state.editMode;
  document.body.classList.toggle('edit-mode', state.editMode);
  if(el.editModeBtn) el.editModeBtn.classList.toggle('active', state.editMode);
  if(el.topEditModeBtn) el.topEditModeBtn.classList.toggle('active', state.editMode);
  updateHeaderControls();
  renderList();
}
if(el.editModeBtn) el.editModeBtn.addEventListener('click', toggleEditMode);
if(el.topEditModeBtn) el.topEditModeBtn.addEventListener('click', toggleEditMode);
  if(el.topDeleteSelectedBtn) el.topDeleteSelectedBtn.addEventListener('click', ()=>{
    if(!state.editMode) return;
    if(state.selectedIds.size === 0){ alert('å‰Šé™¤å¯¾è±¡ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“'); return; }
    if(!confirm(`é¸æŠã•ã‚ŒãŸ ${state.selectedIds.size} ä»¶ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;
    // remove selected
    const ids = Array.from(state.selectedIds);
    DATA = DATA.filter(d=>!ids.includes(d.id));
    state.selectedIds.clear();
    saveToStorage(); renderTags(); renderList();
    if (typeof saveBookmarksToRemote === 'function') saveBookmarksToRemote();
  });
if(el.topOpenAdd) el.topOpenAdd.addEventListener('click', ()=>{ openAddModal(); });
if(el.openAdd) el.openAdd.addEventListener('click', ()=>{ openAddModal(); });
if(el.cancelAdd) el.cancelAdd.addEventListener('click', ()=>{ closeAddModal(); });
if(el.deleteInModal) el.deleteInModal.addEventListener('click', ()=>{
  try{
    const eid = el.saveAdd && el.saveAdd.dataset && el.saveAdd.dataset.editId ? Number(el.saveAdd.dataset.editId) : null;
    if(!eid){ alert('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
    if(!confirm('ã“ã®ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
    DATA = DATA.filter(d=>d.id !== eid);
    delete el.saveAdd.dataset.editId;
    try{ el.deleteInModal.style.display = 'none'; }catch(e){}
    saveToStorage(); renderTags(); renderList(); closeAddModal();
    if (typeof saveBookmarksToRemote === 'function') saveBookmarksToRemote();
  }catch(e){ console.error('deleteInModal error', e); alert('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ'); }
});

if(el.moreTagsBtn) el.moreTagsBtn.addEventListener('click', ()=>{ if(el.tagModal) el.tagModal.style.display='flex'; try{ if(el.tagSearch){ el.tagSearch.value=''; el.tagSearch.focus(); } }catch(e){} });
if(el.closeModal) el.closeModal.addEventListener('click', ()=>{ if(el.tagModal) el.tagModal.style.display='none'; });
if(el.tagSearch) el.tagSearch.addEventListener('input', ()=>{ const q=el.tagSearch.value.trim().toLowerCase(); const all=buildAllTags(DATA); const filtered = all.filter(t=>t.toLowerCase().includes(q)); renderModalTags(filtered); });

function openAddModal(){
  el.addModal.style.display='flex';
  el.addUrl.value=''; el.addTitleInput.value=''; el.addIcon.value=''; el.addDesc.value=''; el.addTags.value='';
  delete el.saveAdd.dataset.editId;
  try{ if(el.deleteInModal) el.deleteInModal.style.display = 'none'; }catch(e){}
  // populate folder select options
  try{
    if(el.addFolder){
      const folders = buildAllFolders(DATA);
      el.addFolder.innerHTML = '';
      const empty = document.createElement('option'); empty.value=''; empty.textContent='ï¼ˆãªã—ï¼‰'; el.addFolder.appendChild(empty);
      folders.forEach(f=>{
        if(f==='All') return;
        const o=document.createElement('option');
        o.value = f;
        const depth = getFolderDepth(f);
        const indent = 'ã€€'.repeat(depth - 1);
        o.textContent = indent + getFolderName(f);
        el.addFolder.appendChild(o);
      });
      // select current folder if any
      if(state.currentFolder && state.currentFolder !== 'All') el.addFolder.value = state.currentFolder; else el.addFolder.value = '';
    }
  }catch(e){ console.warn('populate folders failed', e); }
  setTimeout(()=>el.addUrl.focus(),50);
}
function closeAddModal(){ el.addModal.style.display='none'; }

/* export/import JSON UI removed */

/* JSON import/export feature removed (unused). */

el.pasteUrlBtn.addEventListener('click', async ()=>{
  try{
    const text = await navigator.clipboard.readText();
    if(text.trim()) el.addUrl.value = text.trim();
  } catch(err){
    console.warn('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰èª­ã¿è¾¼ã¿ã«å¤±æ•—: ', err);
    alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚');
  }
});

/* save/add bookmark: ã“ã“ã« saveBookmarksToRemote() å‘¼ã³å‡ºã—ã‚’è¿½åŠ  */
// save/add bookmark: try to fetch page title when title input is empty
el.saveAdd.addEventListener('click', async ()=>{
  const url = el.addUrl.value.trim();
  if(!url){ alert('URL ã¯å¿…é ˆã§ã™'); return; }

  // Debug: log initial input state
  try{ console.debug('[saveAdd] initial input url:', el.addUrl.value, ' initial title input:', el.addTitleInput.value); }catch(e){}

  let title = el.addTitleInput.value.trim();

  async function fetchTitleFromUrl(u){
    try{
      // æ­£è¦åŒ–: ã‚¹ã‚­ãƒ¼ãƒ ãŒç„¡ã‘ã‚Œã° https:// ã‚’ä»˜ä¸ã—ã¦ absolute URL ã«ã™ã‚‹
      let targetUrl = (u || '').toString().trim();
      if(!/^https?:\/\//i.test(targetUrl)){
        targetUrl = 'https://' + targetUrl;
      }
      // quick validate
      try{ new URL(targetUrl); } catch(e){ return null; }
      // try using configured proxy first, supporting both '/fetch?url=' and '?url=' styles,
      // then fall back to direct fetch if proxy is not set or fails.
      const controller = new AbortController();
      const id = setTimeout(()=>controller.abort(), 5000);
      const proxy = getOgpProxy();
      async function tryFetchReturnResponse(url){
        try{
          const r = await fetch(url, { method: 'GET', mode: 'cors', redirect: 'follow', signal: controller.signal });
          if(!r || !r.ok) return null;
          return r;
        }catch(e){ return null; }
      }

      let resp = null;
      // Debug: log which proxy/base will be used
      try{ console.debug('[fetchTitleFromUrl] using proxy:', proxy, ' target:', targetUrl); }catch(e){}
      if(proxy && proxy.trim()){
        const base = proxy.replace(/\/$/, '');
        // try worker-style query first
        resp = await tryFetchReturnResponse(base + '?url=' + encodeURIComponent(targetUrl)) || await tryFetchReturnResponse(base + '/fetch?url=' + encodeURIComponent(targetUrl));
        try{ if(resp) console.debug('[fetchTitleFromUrl] proxy response status:', resp.status, resp.statusText); }catch(e){}
      }
      if(!resp){
        // Do NOT fall back to direct fetch from browser to avoid CORB/CORS issues.
        // If proxy failed or is not set, return null so caller can handle fallback.
        clearTimeout(id);
        return null;
      }
      clearTimeout(id);

      // If proxy/endpoint returned JSON (OGP-only Worker), parse it
      const contentType = (resp.headers && resp.headers.get) ? (resp.headers.get('content-type') || '') : '';
      // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã® Content-Type ã‚’å‡ºåŠ›
      try{ console.debug('[fetchTitleFromUrl] resp content-type:', contentType, ' for ', u); }catch(e){}
      try{
        if(contentType.includes('application/json')){
          // JSON å¿œç­”ã‚’ãƒ­ã‚°ï¼ˆå¤§ãã™ããªã„ã‚ˆã†å…ˆé ­ã®ã¿ï¼‰
          const txt = await resp.clone().text();
          try{ console.debug('[fetchTitleFromUrl] json response:', txt.slice(0,1000)); }catch(e){}
          const json = JSON.parse(txt);
          try{ console.debug('[fetchTitleFromUrl] parsed json:', json && json.ok ? json.meta : json); }catch(e){}
          if(json && json.ok && json.meta){
            const t = cleanTitle(json.meta.title) || json.meta.title || null;
            return { title: t, description: json.meta.description || null, image: json.meta.image || null };
          }
        }
      }catch(e){ console.debug('[fetchTitleFromUrl] json parse failed', e); /* not json or parse failed, fallback to text parsing */ }

      // Fallback: treat response as HTML text and parse for meta tags
      try{
        const text = await resp.text();
        const doc = new DOMParser().parseFromString(text, 'text/html');
        // collect og:title, og:description, og:image (also check name variants)
        const getMeta = (sel) => {
          const el = doc.querySelector(sel) || doc.querySelector(sel.replace('property', 'name'));
          if(!el) return null;
          return el.getAttribute('content') || el.getAttribute('value') || el.textContent || null;
        };
        const ogTitle = getMeta('meta[property="og:title"]') || getMeta('meta[name="twitter:title"]');
        const ogDesc = getMeta('meta[property="og:description"]') || getMeta('meta[name="description"]') || getMeta('meta[name="twitter:description"]');
        const ogImage = getMeta('meta[property="og:image"]') || getMeta('meta[name="twitter:image"]');
        const title = (ogTitle && ogTitle.trim()) || (doc.querySelector('title') && doc.querySelector('title').textContent.trim()) || null;
        return { title: title, description: ogDesc ? (''+ogDesc).trim() : null, image: ogImage ? (''+ogImage).trim() : null };
      }catch(e){ /* parse error */ }
      return null;
    }catch(e){ return null; }
  }

  // If fetchTitleFromUrl returned null for title but URL is a known provider (YouTube),
  // try a public oEmbed-like fallback (noembed.com) to get title/thumbnail.
  try{
    const host = (new URL(targetUrl)).hostname.toLowerCase();
    const providerHosts = ['youtube.com','www.youtube.com','youtu.be'];
    if(providerHosts.includes(host) || providerHosts.some(h=>host.endsWith('.' + h))){
      try{
        const oe = await fetch('https://noembed.com/embed?url=' + encodeURIComponent(targetUrl), { method:'GET', mode:'cors' });
        if(oe && oe.ok){
          const j = await oe.json();
          // noembed returns { title, author_name, thumbnail_url, ... }
          return { title: j.title || null, description: j.author_name || null, image: j.thumbnail_url || null };
        }
      }catch(e){ /* ignore noembed errors */ }
    }
  }catch(e){ /* ignore */ }

  // only attempt fetch when title is empty
  let fetched = null;
    if(!title){
    try{ fetched = await fetchTitleFromUrl(url); }catch(e){}
    if(fetched && fetched.title){
      try{ console.debug('[saveAdd] fetched.title (raw):', fetched.title); }catch(e){}
      const cleaned = cleanTitle(fetched.title);
      try{ console.debug('[saveAdd] fetched.title (cleaned):', cleaned); }catch(e){}
      title = cleaned || null;
    }
  } else {
    // even if title provided, we may still want description/icon from ogp
    try{ fetched = await fetchTitleFromUrl(url); }catch(e){}
  }

  // fallback to hostname or the raw url -- but require confirmation if OGP fetch failed
  try{
    if(!title){
      if(fetched === null){
        // OGP fetch failed or was blocked (CORB/CORS). Ask user before saving a fallback title.
        const proceed = confirm('ãƒšãƒ¼ã‚¸æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¿ã‚¤ãƒˆãƒ«ãŒç©ºã®ã¾ã¾ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ\n(ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ã¨ä¿å­˜ã‚’ä¸­æ­¢ã—ã¾ã™)');
        if(!proceed){
          return; // abort save
        }
      }
      title = (new URL(url)).hostname;
    }
  } catch(e){ if(!title) title = url; }

  // decide icon and desc: prefer user-specified, otherwise OGP (via proxy), otherwise favicon
  let icon = el.addIcon.value.trim();
  // ã¾ãšãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã‚’å„ªå…ˆ
  if(!icon){
    // OGP ã§å–å¾—ã§ãã¦ã„ã‚‹å ´åˆã¯æ¡ç”¨ï¼ˆãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§ä¿å­˜ã™ã‚‹ã®ã§ CORS å•é¡Œã¯å›é¿ã•ã‚Œã‚‹ï¼‰
    if(fetched && fetched.image){
      // Store the original OGP image URL (will be proxied when rendered)
      icon = fetched.image;
    } else {
      // No OGP image: use favicon as fallback
      icon = faviconFromUrl(url,64);
    }
  }
  let desc = el.addDesc.value.trim();
  if(!desc && fetched && fetched.description) desc = fetched.description;
  const tags = (el.addTags.value||'').split(/[,;|]/).map(s=>s.trim()).filter(Boolean);
  const folder = (el.addFolder && el.addFolder.value) ? el.addFolder.value.trim() : '';

  // Debug: final title before save
  try{ console.debug('[saveAdd] final title before save:', title); }catch(e){}

  // ensure input shows the final title
  try{ if(title) el.addTitleInput.value = title; }catch(e){}

  if(el.saveAdd.dataset.editId){
    const eid = Number(el.saveAdd.dataset.editId);
    const idx = DATA.findIndex(d=>d.id === eid);
    if(idx !== -1){
      // ç·¨é›†æ™‚ã«ä»–ã®ã‚¨ãƒ³ãƒˆãƒªã¨ URL ãŒé‡è¤‡ã—ãªã„ã‹ãƒã‚§ãƒƒã‚¯
      try{
        const newKey = normalizeUrlForCompare(url);
        const dup = DATA.some((d,i)=> i !== idx && normalizeUrlForCompare(d.url) === newKey);
        if(dup){ alert('åˆ¥ã®ã‚¨ãƒ³ãƒˆãƒªã¨ URL ãŒé‡è¤‡ã—ã¾ã™ã€‚ç·¨é›†ã‚’ä¸­æ­¢ã—ã¾ã—ãŸã€‚'); return; }
      }catch(e){}
      const created = DATA[idx].created_at || Date.now();
      DATA[idx].url = url; DATA[idx].title = title; DATA[idx].icon_url = icon; DATA[idx].desc = desc; DATA[idx].tags = tags; DATA[idx].folder = folder || ''; DATA[idx].created_at = created;
    }
  } else {
    // è¿½åŠ å‰ã«é‡è¤‡ URL ã‚’ãƒã‚§ãƒƒã‚¯
    try{
      const newKey = normalizeUrlForCompare(url);
      const exists = (DATA || []).some(d=> normalizeUrlForCompare(d.url) === newKey );
      if(exists){ alert('åŒã˜ URL ã®ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚'); return; }
    }catch(e){}
    const id = Date.now() + Math.floor(Math.random()*1000);
    DATA.unshift({ id, title, url, icon_url: icon, desc, tags, folder: folder || '', created_at: Date.now() });
  }

  saveToStorage();
  renderTags(); renderList();
  closeAddModal();
  if (typeof saveBookmarksToRemote === 'function') saveBookmarksToRemote();
});

// Enterã‚­ãƒ¼ã«ã‚ˆã‚‹è‡ªå‹•ä¿å­˜æ©Ÿèƒ½ã¯ç„¡åŠ¹åŒ–ã—ã¾ã—ãŸï¼ˆèª¤ä¿å­˜é˜²æ­¢ã®ãŸã‚ï¼‰ã€‚

/* init */
// load and dedupe stored bookmarks
if(!loadAndDedupeFromStorage()){
  // keep initial DATA if local empty
}
loadViewMode(); // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã‚’ localStorage ã‹ã‚‰èª­ã¿è¾¼ã¿
loadSort(); // ã‚½ãƒ¼ãƒˆè¨­å®šã‚’ localStorage ã‹ã‚‰èª­ã¿è¾¼ã¿
updateViewModeUI(); // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
loadFolder(); // currentFolder ã‚’èª­ã¿è¾¼ã¿
updateFolderUI();
renderFolderList();
renderTags(); renderList();

function adjustWrapForHeader(){
  const hdr = document.querySelector('header.card');
  const wrap = document.querySelector('.wrap');
  if(hdr && wrap){
    const h = hdr.offsetHeight || 0;
    // align content directly under header; minimize extra gap
    wrap.style.paddingTop = (h) + 'px';
    // expose header height as CSS variable so sticky elements can align exactly
    try{ document.documentElement.style.setProperty('--hdr-h', h + 'px'); }catch(e){}
  }
}
adjustWrapForHeader();
window.addEventListener('resize', adjustWrapForHeader);

const headerEl = document.querySelector('header.card');
const headerToggle = document.getElementById('headerToggle');
if(headerToggle && headerEl){
  function setInitialCollapsed(){ if(window.innerWidth <= 560){ headerEl.classList.add('collapsed'); headerToggle.setAttribute('aria-expanded','false'); } else { headerEl.classList.remove('collapsed'); headerToggle.setAttribute('aria-expanded','true'); } }
  setInitialCollapsed();
  window.addEventListener('resize', setInitialCollapsed);
  // Replace collapse toggle with an anchored view-mode menu (same behavior as kyu68002_links.html)
  let viewMenuEl = null;
  function createViewMenu(){
    const wrap = document.getElementById('viewToggleWrap');
    if(!wrap) return null;
    const existing = wrap.querySelector('.view-mode-menu');
    if(existing) return existing;
    const menu = document.createElement('div'); menu.className='view-mode-menu';
    menu.style.position='absolute'; menu.style.top='calc(100% + 6px)'; menu.style.left='0'; menu.style.zIndex='1020'; menu.style.background='var(--card)'; menu.style.border='1px solid rgba(6,50,58,0.08)'; menu.style.borderRadius='10px'; menu.style.padding='10px'; menu.style.boxShadow='0 8px 24px rgba(2,18,22,0.12)'; menu.style.minWidth='160px';
    const title = document.createElement('div'); title.className='menu-title'; title.textContent='è¡¨ç¤ºã‚µã‚¤ã‚º'; title.style.fontWeight='700'; title.style.marginBottom='8px'; menu.appendChild(title);
    ['small','medium'].forEach(mode=>{
      const row = document.createElement('label'); row.className='menu-radio'; row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.padding='6px 8px'; row.style.cursor='pointer';
      const r = document.createElement('input'); r.type='radio'; r.name='viewMode'; r.value=mode; r.style.cursor='pointer';
      r.checked = (state.viewMode === mode);
      r.addEventListener('change', ()=>{ state.viewMode = r.value; saveViewMode(); renderList(); updateViewModeUI(); });
      const span = document.createElement('span'); span.textContent = mode==='small' ? 'å°ï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆï¼‰' : 'é€šå¸¸';
      row.appendChild(r); row.appendChild(span); menu.appendChild(row);
    });
    // sort select (sync with header sort)
    const sWrap = document.createElement('div'); sWrap.style.marginTop='8px';
    const s = document.createElement('select'); s.style.width='100%'; s.innerHTML = (document.getElementById('sort') || {innerHTML:''}).innerHTML;
    try{ s.value = document.getElementById('sort').value; }catch(e){}
    s.addEventListener('change',(e)=>{ try{ document.getElementById('sort').value = e.target.value; document.getElementById('sort').dispatchEvent(new Event('change')); }catch(err){} });
    sWrap.appendChild(s); menu.appendChild(sWrap);
    wrap.appendChild(menu);
    return menu;
  }
  function toggleViewMenu(ev){ ev && ev.stopPropagation(); if(!viewMenuEl) viewMenuEl = createViewMenu(); if(!viewMenuEl) return; const vis = viewMenuEl.style.display !== 'block'; viewMenuEl.style.display = vis ? 'block' : 'none'; headerToggle.setAttribute('aria-expanded', vis ? 'true' : 'false'); }
  headerToggle.addEventListener('click', (ev)=>{ toggleViewMenu(ev); });
  document.addEventListener('click', (ev)=>{ if(viewMenuEl && viewMenuEl.style.display === 'block'){ const wrap = document.getElementById('viewToggleWrap'); if(!wrap.contains(ev.target)) viewMenuEl.style.display='none'; } });

  // Ensure padding is correct after initial collapsed state is applied
  try{ adjustWrapForHeader(); }catch(e){}
}

window.LINKS_DATA = DATA; window.rebuild = ()=>{ renderTags(); renderList(); };

document.addEventListener('keydown', async (e)=>{
  if((e.ctrlKey || e.metaKey) && e.key === 'v'){
    if(!e.target.matches('input, textarea')){
      e.preventDefault();
      try{
        const text = await navigator.clipboard.readText();
        if(text.trim()){
          openAddModal();
          el.addUrl.value = text.trim();
          setTimeout(()=>el.addTitleInput.focus(), 100);
        }
      } catch(err){
        console.warn('Clipboard paste failed:', err);
      }
    }
  }
  if((e.ctrlKey || e.metaKey) && e.key === 'i'){
    e.preventDefault();
    toggleEditMode();
  }
});

/* ------------------ Firebase + RealtimeDB åŒæœŸ + Google Sign-in ------------------ */

/* --- your firebaseConfig --- */
const firebaseConfig = {
  apiKey: "AIzaSyDJjrwdBvHp5nGCVggO77vLIfobfFAVwWA",
  authDomain: "link-fd2f7.firebaseapp.com",
  databaseURL: "https://link-fd2f7-default-rtdb.firebaseio.com",
  projectId: "link-fd2f7",
  storageBucket: "link-fd2f7.firebasestorage.app",
  messagingSenderId: "856041551674",
  appId: "1:856041551674:web:b9e059f7fb6f789dadc203"
};

/* ensure firebase SDK loaded */
if (!window.firebase) {
  console.error('Firebase SDK ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚index.html ã§ SDK ã‚’ä¸€åº¦ã ã‘èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚');
} else {
  if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    // Try to set persistence at init time without awaiting so popup remains user-initiated on mobile Safari
    try {
      if (firebase.auth && firebase.auth().setPersistence) {
        firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(e => console.warn('setPersistence init failed', e));
      }
    } catch (e) {
      console.warn('setPersistence init error', e);
    }
}

const db = (window.firebase) ? firebase.database() : null;
let firebaseUid = null;
let currentRemoteRef = null;

/* local <-> functions (DATA ã‚’ä½¿ã†) */
function getLocalBookmarks(){
  if (typeof DATA !== 'undefined' && Array.isArray(DATA)) return DATA;
  if (typeof window !== 'undefined' && Array.isArray(window.DATA)) return window.DATA;
  return [];
}
function setLocalBookmarks(arr){
  const normalized = Array.isArray(arr) ? arr : [];
  try{ DATA = normalized; } catch(e){}
  try{ window.DATA = normalized; } catch(e){}
  try { saveToStorage(); } catch(e){ try { localStorage.setItem(STORAGE_KEY, JSON.stringify(normalized)); } catch(_){} }
  try { renderTags(); renderList(); } catch(e){ /* ignore */ }
}

function ensureIdAndTsForSync(item){
  if (!item) item = {};
  if (!item.id) {
    if (window.crypto && crypto.randomUUID) item.id = crypto.randomUUID();
    else item.id = String(Date.now()) + '-' + Math.floor(Math.random()*1000);
  }
  if (!item.created_at) item.created_at = Date.now();
  item.updated_at = Date.now();
  return item;
}

function arrayOrObjToMap(data){
  const m = {};
  if (!data) return m;
  if (Array.isArray(data)) data.forEach(it => { if(it && it.id) m[it.id] = it; });
  else if (typeof data === 'object') Object.values(data).forEach(it => { if(it && it.id) m[it.id] = it; });
  return m;
}
function mapToArray(mapObj){ return Object.values(mapObj || {}); }
function deepEqualMaps(a,b){
  const ka = Object.keys(a||{}).sort();
  const kb = Object.keys(b||{}).sort();
  if (ka.length !== kb.length) return false;
  for(let k of ka){
    if(!b[k]) return false;
    if (JSON.stringify(a[k]) !== JSON.stringify(b[k])) return false;
  }
  return true;
}

/* sync */
function startSyncForUser(uid){
  if (!uid || !db) return;
  firebaseUid = uid;
  console.log('startSyncForUser uid=', uid);
  const path = 'bookmarks/' + uid;
  const ref = db.ref(path);

  if (currentRemoteRef && typeof currentRemoteRef.off === 'function') {
    try { currentRemoteRef.off(); } catch(e){ /* ignore */ }
  }
  currentRemoteRef = ref;

  ref.once('value').then(snap => {
    const remoteVal = snap.val();
    try{
      if (remoteVal && ((Array.isArray(remoteVal) && remoteVal.length > 0) || (typeof remoteVal === 'object' && Object.keys(remoteVal).length > 0))) {
        const arr = mapToArray(arrayOrObjToMap(remoteVal)).sort((a,b)=> (b.updated_at||0)-(a.updated_at||0));
        setLocalBookmarks(arr);
      } else {
        // ãƒªãƒ¢ãƒ¼ãƒˆã«ãƒ‡ãƒ¼ã‚¿ãŒç„¡ã‘ã‚Œã°ã€ãƒ­ã‚°ã‚¤ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ã‚«ãƒ«ã¯ç©ºã«ã™ã‚‹
        setLocalBookmarks([]);
      }
    }catch(e){ console.error(e); }
  }).catch(console.error);

  ref.on('value', snapshot => {
    const remoteVal = snapshot.val() || [];
    try {
      const arr = mapToArray(arrayOrObjToMap(remoteVal)).sort((a,b)=> (b.updated_at||0)-(a.updated_at||0));
      setLocalBookmarks(arr);
    } catch(e){ console.error(e); }
  });
}

function handleRemoteSnapshot(remoteVal, ref){
  // ãƒªãƒ¢ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ãŒæ­£ã—ã„å˜ä¸€ã‚½ãƒ¼ã‚¹ã¨ãªã‚‹ã‚ˆã†ã€å˜ç´”ã«ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¸Šæ›¸ãã™ã‚‹
  try{
    const arr = mapToArray(arrayOrObjToMap(remoteVal)).sort((a,b)=> (b.updated_at||0)-(a.updated_at||0));
    setLocalBookmarks(arr);
  }catch(e){ console.error('handleRemoteSnapshot error', e); }
}

function saveBookmarksToRemote(){
  if (!firebaseUid || !db){ console.warn('saveBookmarksToRemote: no firebase uid/db'); return; }
  const ref = db.ref('bookmarks/' + firebaseUid);
  const local = (getLocalBookmarks() || []).map(it => ensureIdAndTsForSync(it));
  console.log('saveBookmarksToRemote uid=', firebaseUid, 'items=', local.length);
  ref.set(local).then(()=>{ console.log('saveBookmarksToRemote: saved', firebaseUid); }).catch(err=>{ console.error('saveBookmarksToRemote error', err); alert('ãƒªãƒ¢ãƒ¼ãƒˆä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (err && err.message || err)); });
}

/* helper wrapper */
function addBookmarkAndSync(bookmark){
  bookmark = ensureIdAndTsForSync(bookmark);
  const local = getLocalBookmarks();
  local.unshift(bookmark);
  setLocalBookmarks(local);
  saveBookmarksToRemote();
}

/* ---------- Auth UI handling ---------- */
// DOMè¦ç´ 
const userInfoBtn = document.getElementById('userInfoBtn');
const userMiniAvatar = document.getElementById('userMiniAvatar');
const userInfoText = document.getElementById('userInfoText');
const userSettingsModal = document.getElementById('userSettingsModal');
const userAvatarLarge = document.getElementById('userAvatarLarge');
const avatarUploadInput = document.getElementById('avatarUploadInput');
const uploadAvatarBtn = document.getElementById('uploadAvatarBtn');
const googleSignInBtn2 = document.getElementById('googleSignInBtn2');
const signOutBtn2 = document.getElementById('signOutBtn2');
const loginSection = document.getElementById('loginSection');
const logoutSection = document.getElementById('logoutSection');
const loggedInEmail = document.getElementById('loggedInEmail');
const closeUserSettingsModal = document.getElementById('closeUserSettingsModal');

let userAvatarUrl = null;

// ãƒ¢ãƒ¼ãƒ€ãƒ«é–‹é–‰
function openUserSettingsModal(){
  if(userSettingsModal) userSettingsModal.style.display = 'flex';
  updateModalLoginSection();
  try{
    const v = localStorage.getItem('ogp_proxy') || '';
    const inp = document.getElementById('ogpProxyInput');
    if(inp) inp.value = v;
  }catch(e){}
}
function closeUserSettingsModalFn(){
  if(userSettingsModal) userSettingsModal.style.display = 'none';
}
if(userInfoBtn) userInfoBtn.addEventListener('click', openUserSettingsModal);
if(closeUserSettingsModal) closeUserSettingsModal.addEventListener('click', closeUserSettingsModalFn);
if(userSettingsModal) userSettingsModal.addEventListener('click', (e)=>{ if(e.target === userSettingsModal) closeUserSettingsModalFn(); });

// ãƒ­ã‚°ã‚¤ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤ºåˆ‡æ›¿
function updateModalLoginSection(){
  const user = (window.firebase && firebase.auth) ? firebase.auth().currentUser : null;
  if(user && !user.isAnonymous){
    if(loginSection) loginSection.style.display = 'none';
    if(logoutSection) logoutSection.style.display = 'block';
    if(loggedInEmail) loggedInEmail.textContent = 'ãƒ­ã‚°ã‚¤ãƒ³ä¸­: ' + (user.email || user.uid);
  } else {
    if(loginSection) loginSection.style.display = 'block';
    if(logoutSection) logoutSection.style.display = 'none';
  }
}

// ãƒ˜ãƒƒãƒ€ãƒ¼ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±æ›´æ–°
function updateAuthUI(user){
  if(!userInfoText) return;
  if(!user){
    userInfoText.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼: ã‚²ã‚¹ãƒˆ';
    if(userMiniAvatar) userMiniAvatar.innerHTML = 'ğŸ‘¤';
    if(userAvatarLarge) userAvatarLarge.innerHTML = 'ğŸ‘¤';
    // æœªãƒ­ã‚°ã‚¤ãƒ³æ™‚ã¯ãƒ­ãƒ¼ã‚«ãƒ«ã®ä¸€è¦§ã‚’ã‚¯ãƒªã‚¢ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³ä¿ƒé€²ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
    try{ setLocalBookmarks([]); } catch(e){}
    try{
      if(el && el.countText) el.countText.textContent = 'ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ä¸‹ã•ã„';
      if(el && el.list) el.list.innerHTML = '<div id="guestLoginPrompt" style="color:var(--muted);padding:14px;border-radius:10px;background:var(--card);cursor:pointer">ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ä¸‹ã•ã„</div>';
      // attach click handler to the guest login prompt area to open user settings modal
      setTimeout(()=>{
        const wrap = document.getElementById('guestLoginPrompt');
        if(wrap){ wrap.addEventListener('click', ()=>{ openUserSettingsModal(); }); }
      },50);
      // éãƒ­ã‚°ã‚¤ãƒ³æ™‚ã¯è¿½åŠ ã‚„ç·¨é›†ãƒœã‚¿ãƒ³ã‚’éš ã™
      if(el && el.openAdd) el.openAdd.style.display = 'none';
      if(el && el.topOpenAdd) el.topOpenAdd.style.display = 'none';
      if(el && el.editModeBtn) el.editModeBtn.style.display = 'none';
      if(el && el.topEditModeBtn) el.topEditModeBtn.style.display = 'none';
    }catch(e){}
  } else {
    // ãƒ­ã‚°ã‚¤ãƒ³æ™‚ã¯ UI ã‚’æœ‰åŠ¹åŒ–
    try{
      if(el && el.openAdd) el.openAdd.style.display = '';
      if(el && el.topOpenAdd) el.topOpenAdd.style.display = '';
      if(el && el.editModeBtn) el.editModeBtn.style.display = '';
      if(el && el.topEditModeBtn) el.topEditModeBtn.style.display = '';
    }catch(e){}
    const isAnonymous = user.isAnonymous === true;
    const displayText = isAnonymous ? 'ã‚²ã‚¹ãƒˆ' : (user.email || user.displayName || user.uid);
    userInfoText.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼: ' + displayText;
    // ã‚¢ãƒã‚¿ãƒ¼ï¼ˆphotoURL ãŒç„¡ã‘ã‚Œã° providerDataã€ã•ã‚‰ã« localStorage ã‚’ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    try{ console.log('updateAuthUI user:', user); }catch(e){}
    const savedAvatar = localStorage.getItem('userAvatar');
    const providerPhoto = (user.providerData && Array.isArray(user.providerData) && user.providerData.length)
      ? (user.providerData.find(p=>p && p.photoURL) || {}).photoURL
      : null;
    const photoURL = user.photoURL || providerPhoto || savedAvatar || null;

    if(photoURL){
      userAvatarUrl = photoURL;
      // img è¦ç´ ã‚’ç”Ÿæˆã—ã¦å®‰å…¨ã«å·®ã—æ›¿ãˆã‚‹
      try{
        const miniImg = document.createElement('img');
        miniImg.alt = 'avatar';
        miniImg.src = photoURL;
        miniImg.style.width = '100%';
        miniImg.style.height = '100%';
        miniImg.style.objectFit = 'cover';
        miniImg.onerror = ()=>{ if(userMiniAvatar) userMiniAvatar.innerHTML = 'ğŸ‘¤'; };

        const largeImg = document.createElement('img');
        largeImg.alt = 'avatar';
        largeImg.src = photoURL;
        largeImg.style.width = '100%';
        largeImg.style.height = '100%';
        largeImg.style.objectFit = 'cover';
        largeImg.onerror = ()=>{ if(userAvatarLarge) userAvatarLarge.innerHTML = 'ğŸ‘¤'; };

        if(userMiniAvatar){ userMiniAvatar.innerHTML = ''; userMiniAvatar.appendChild(miniImg); }
        if(userAvatarLarge){ userAvatarLarge.innerHTML = ''; userAvatarLarge.appendChild(largeImg); }
      } catch(e){
        if(userMiniAvatar) userMiniAvatar.innerHTML = 'ğŸ‘¤';
        if(userAvatarLarge) userAvatarLarge.innerHTML = 'ğŸ‘¤';
      }
      // ã‚¢ãƒã‚¿ãƒ¼è¡¨ç¤ºã®ã¿ï¼ˆãƒ•ã‚¡ãƒ“ã‚³ãƒ³ã®å¤‰æ›´ã¯ä¸è¦ãªã®ã§å®Ÿè¡Œã—ãªã„ï¼‰
    } else {
      if(userMiniAvatar) userMiniAvatar.innerHTML = 'ğŸ‘¤';
      if(userAvatarLarge) userAvatarLarge.innerHTML = 'ğŸ‘¤';
    }
  }
  updateModalLoginSection();
}

// ãƒ•ã‚¡ãƒ“ã‚³ãƒ³åˆ¶å¾¡ã¯å‰Šé™¤ï¼ˆä¸è¦ï¼‰

// ã‚¢ãƒã‚¿ãƒ¼ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
if(uploadAvatarBtn) uploadAvatarBtn.addEventListener('click', ()=>{ if(avatarUploadInput) avatarUploadInput.click(); });
if(avatarUploadInput) avatarUploadInput.addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    userAvatarUrl = ev.target.result;
    if(userMiniAvatar) userMiniAvatar.innerHTML = `<img src="${userAvatarUrl}" alt="avatar">`;
    if(userAvatarLarge) userAvatarLarge.innerHTML = `<img src="${userAvatarUrl}" alt="avatar">`;
    localStorage.setItem('userAvatar', userAvatarUrl);
    // DBã«ã‚‚ä¿å­˜
    const uid = firebaseUid || (window.firebase && firebase.auth && firebase.auth().currentUser && firebase.auth().currentUser.uid);
    if(uid && db){
      db.ref(`users/${uid}`).update({ avatar: userAvatarUrl }).catch(e=>console.warn('avatar save failed',e));
    }
  };
  reader.readAsDataURL(file);
});

/* OGP proxy UI bindings removed â€” using hidden default proxy set in OGP_PROXY constant */

async function signInWithGoogle(){
  if (!window.firebase) return alert('Firebase SDKãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
  const provider = new firebase.auth.GoogleAuthProvider();
  provider.addScope('profile');
  provider.addScope('email');
    try {
      // Detect iOS Safari (popup handling is unreliable there) and use redirect
      const ua = navigator.userAgent || '';
      const isIos = /iP(hone|od|ad)/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      const isSafari = /Safari/.test(ua) && !/CriOS|FxiOS|OPiOS|EdgiOS/.test(ua);
      const useRedirect = isIos && isSafari;
      if (useRedirect) {
        // Redirect flow is more reliable on iOS Safari
        try{
          // Ensure persistence is set before redirect (await so Safari applies it)
          if (firebase.auth && firebase.auth().setPersistence) {
            await firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL);
          }
        }catch(e){ console.warn('setPersistence before redirect failed', e); }
        try{ localStorage.setItem('auth_redirecting', '1'); }catch(e){}
        await firebase.auth().signInWithRedirect(provider);
        return;
      }
      // setPersistence already attempted at init; attempt again but don't await to avoid breaking user gesture
      try{ firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(()=>{}); } catch(e){}
      const res = await firebase.auth().signInWithPopup(provider);
      console.log('signInWithPopup result:', res && res.user && res.user.uid);
      // ã‚µã‚¤ãƒ³ã‚¤ãƒ³ç›´å¾Œã«æ˜ç¤ºçš„ã«åŒæœŸã‚’é–‹å§‹ã—ã€res.user ã‚’ä½¿ã£ã¦ç¢ºå®Ÿã«åŒæœŸã‚’è¡Œã†
      try{
        const signedUser = (res && res.user) ? res.user : (firebase.auth().currentUser || null);
        if(signedUser && signedUser.uid){
          // ç¢ºå®Ÿã« firebaseUid ã‚’è¨­å®š
          firebaseUid = signedUser.uid;
          startSyncForUser(signedUser.uid);
          const local = getLocalBookmarks() || [];
          if(local.length > 0){
            console.log('Local has items after signIn, pushing to remote');
            saveBookmarksToRemote();
          }
        } else {
          console.warn('No signedUser found after signInWithPopup');
        }
      }catch(e){ console.warn('postSignIn sync failed', e); }
      return;
    } catch(e){
      console.error('Google sign-in error', e);
      alert('Googleã‚µã‚¤ãƒ³ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (e && (e.message || e.code) || e));
    }
}

async function signOut(){
  try {
    await firebase.auth().signOut();
    alert('ã‚µã‚¤ãƒ³ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ');
  } catch(e){
    console.error('signOut error', e);
    alert('ã‚µã‚¤ãƒ³ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼: ' + (e && (e.message || e.code) || e));
  }
}

if (googleSignInBtn2) googleSignInBtn2.addEventListener('click', signInWithGoogle);
if (signOutBtn2) signOutBtn2.addEventListener('click', async ()=>{
  await signOut();
  closeUserSettingsModalFn();
});

/* onAuthStateChanged */
if (window.firebase) {
  firebase.auth().onAuthStateChanged(async user => {
    console.log('onAuthStateChanged user:', user && (user.uid || user.email));
    updateAuthUI(user);
    if (!user) {
      // æœªãƒ­ã‚°ã‚¤ãƒ³æ™‚ã¯ä½•ã‚‚ã—ãªã„
      console.warn('No authenticated user');
      return;
    }
      try{ localStorage.removeItem('auth_redirecting'); }catch(e){}
    try{
      startSyncForUser(user.uid);
    }catch(e){ console.error('startSyncForUser failed', e); }
  });

  // Handle redirect results explicitly to ensure mobile redirect flows complete login
  try{
    firebase.auth().getRedirectResult().then(result => {
      if(result && result.user){
        console.log('getRedirectResult user:', result.user.uid);
        try{ firebaseUid = result.user.uid; }catch(e){}
        try{ updateAuthUI(result.user); }catch(e){}
        try{ startSyncForUser(result.user.uid); }catch(e){ console.warn('startSyncForUser after redirect failed', e); }
        try{ localStorage.removeItem('auth_redirecting'); }catch(e){}
      }
    }).catch(err => {
      console.warn('getRedirectResult error', err);
    });
  }catch(e){ console.warn('getRedirectResult init error', e); }
}

/* merge anonymous -> target */
/* anonymous-merge logic removed: app now requires explicit Google login only */

/* unload ä¿é™º */
window.addEventListener('beforeunload', ()=>{ try{ saveBookmarksToRemote(); } catch(e){} });
</script>

<!-- Cookie consent banner (inserted by assistant) -->
<style>
  #cookieBanner {
    position:fixed;
    left:16px;
    right:16px;
    bottom:18px;
    z-index:1200;
    background: rgba(15, 184, 191, 0.98);
    color: #fff;
    padding:12px 14px;
    border-radius:12px;
    box-shadow: 0 8px 24px rgba(2,18,22,0.12);
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:space-between;
    max-width:980px;
    margin:0 auto;
    box-sizing:border-box;
    font-size:14px;
  }
  #cookieBanner .msg{flex:1;min-width:0; margin-right:12px; color: #02292c; font-weight:700}
  #cookieBanner .actions{display:flex;gap:8px;align-items:center;flex-shrink:0}
  #cookieBanner .cookie-btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
  #cookieBanner .cookie-accept{background:#fff;color:var(--text)}
  #cookieBanner .cookie-more{background:transparent;color:#fff;border:1px solid rgba(255,255,255,0.3)}
  @media(max-width:560px){
    #cookieBanner{left:10px;right:10px;padding:10px;flex-direction:column;align-items:flex-start;gap:8px}
    #cookieBanner .actions{align-self:stretch;justify-content:flex-end;width:100%}
    #cookieBanner .msg{font-size:15px;font-weight:700;color:#fff}
    #cookieBanner .cookie-accept{width:110px}
  }
</style>

<div id="cookieBanner" role="region" aria-label="ã‚¯ãƒƒã‚­ãƒ¼ã®åˆ©ç”¨ã«ã¤ã„ã¦" hidden>
  <div class="msg">å½“ã‚µã‚¤ãƒˆã¯æ­£å¸¸ãªå‹•ä½œã®ãŸã‚ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ç¶šè¡Œã™ã‚‹ã“ã¨ã§åŒæ„ã—ãŸã‚‚ã®ã¨ã¿ãªã—ã¾ã™ã€‚</div>
  <div class="actions">
    <button class="cookie-btn cookie-more" id="cookieMore">è©³ç´°</button>
    <button class="cookie-btn cookie-accept" id="cookieAccept">åŒæ„ã™ã‚‹</button>
  </div>
</div>

<script>
(function(){
  try{
    const BANNER_KEY = 'cookie_consent_v1';
    const banner = document.getElementById('cookieBanner');
    const acceptBtn = document.getElementById('cookieAccept');
    const moreBtn = document.getElementById('cookieMore');

    function showBanner(){
      if(!banner) return;
      banner.hidden = false;
      banner.style.display = '';
      acceptBtn && acceptBtn.focus();
      console.log('cookieBanner shown');
    }
    function hideBanner(){
      if(!banner) return;
      try{ banner.hidden = true; }catch(e){}
      try{ banner.style.display = 'none'; }catch(e){}
      console.log('cookieBanner hidden');
    }

    function hasConsent(){
      try{ return localStorage.getItem(BANNER_KEY) === '1'; }catch(e){ return false; }
    }
    function setConsent(){
      try{ localStorage.setItem(BANNER_KEY, '1'); }catch(e){}
    }

    if(!hasConsent()) window.requestAnimationFrame(()=>{ showBanner(); }); else hideBanner();

    // Use both addEventListener and onclick assignment to be robust
    if(acceptBtn){
      acceptBtn.addEventListener('click', onAccept);
      acceptBtn.onclick = onAccept;
    }
    if(moreBtn){
      moreBtn.addEventListener('click', ()=>{ window.open('#','_blank','noopener'); });
      moreBtn.onclick = ()=>{ window.open('#','_blank','noopener'); };
    }

    function onAccept(e){
      console.log('cookie accept clicked', e);
      setConsent();
      hideBanner();
    }

    document.addEventListener('keydown', (e)=>{ if((e.key==='Escape' || e.key==='Esc') && banner && !banner.hidden){ setConsent(); hideBanner(); } });
  }catch(e){ console.warn('cookie banner init error', e); }
})();
</script>

</body>
</html>
